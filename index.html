<!DOCTYPE html>     
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Ensure proper scaling on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tap&Say Text Editor</title>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

  <style>
    /*******************************************************
     * 0) Page Layout: Sticky Footer + Gradient Background
     *******************************************************/
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      box-sizing: border-box;
      overflow-x: hidden;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      display: flex;
      flex-direction: column;
      min-height: 100vh; /* Ensure page is at least as tall as the viewport */
    }
    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e9f2 100%);
    }
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1.2rem 0; /* Reduce vertical padding */
    }
    #header-container, #footer-container {
      width: 100%;
      margin: 0;
      padding: 0;
      flex-shrink: 0;
    }
    .container {
      width: 85%;
      max-width: 900px; /* Limit maximum width */
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* è°ƒæ•´å¡ç‰‡é—´è· */
    #monitoring-card {
      margin-bottom: 2rem !important;
    }
    #experience-mode, #input-mode {
      margin-bottom: 2rem !important;
    }
    #event-log-card {
      margin-top: 1rem !important;
    }
    /* ä¿æŒæ¨¡å¼æŒ‰é’®å’Œä¸»ä½“å¡ç‰‡çš„é—´è·ä¸å˜ */
    #mode-buttons {
      margin-bottom: 20px;
    }

    /*******************************************************
     * Additional Class for JS Dynamic Toggle:
     * Disable Long Press Menu / Text Selection
     *******************************************************/
    .disable-ime {
      -webkit-touch-callout: none; /* Disable iOS long press menu */
      -webkit-user-select: none;   /* Disable text selection on iOS */
      user-select: none;           /* Disable text selection on Android/PC */
    }

    /*******************************************************
     * 1) Mode Button Container (#mode-buttons):
     * Large Buttons with Rounded Corners
     *******************************************************/
    #mode-buttons {
      display: flex;
      justify-content: space-between; /* Align buttons to both ends */
      align-items: center;
      margin-bottom: 20px; /* Consistent spacing with other cards */
      gap: 15px; /* Space between buttons */
      width: 100%; /* Ensure width matches container */
    }
    .mode-button {
      flex: 1; /* Evenly distribute button space */
      max-width: calc(50% - 10px); /* Prevent buttons from becoming too wide */
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 15px;
      background: #ffffff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      cursor: pointer;
      font-size: 1rem;
      color: #4a5568;
      text-align: center;
      transition: all 0.3s ease;
    }
    .mode-button.active {
      background: #4299e1;
      color: #fff;
    }
    .mode-button:hover:not(.active) {
      background: #f7fafc;
      transform: translateY(-1px);
    }

    /*******************************************************
     * 2) Card (.card): Rounded Corners + Shadow
     *******************************************************/
    .card {
      border-radius: 15px;
      padding: 30px; /* Maintain consistent internal padding */
      margin-bottom: 20px; /* Reduce spacing between cards */
      background: #fff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      font-size: 1rem; /* Smaller base font size */
    }
    .card:last-child {
      margin-bottom: 0;
    }
    .card h3 {
      font-size: 1.5rem; /* Smaller title font size */
      margin-bottom: 1.2rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* æ·»åŠ å½•éŸ³çŠ¶æ€æŒ‡ç¤ºåœ†ç‚¹æ ·å¼ */
    .recording-status-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background-color: #666;  /* é»˜è®¤ä¸ºç°è‰² */
      display: inline-block;
      transition: background-color 0.3s ease;
      vertical-align: middle; /* ç¡®ä¿ä¸æ–‡å­—å¯¹é½ */
      margin-left: 0; /* ç§»é™¤å·¦è¾¹è· */
    }

    .recording-status-dot.recording {
      background-color: #28a745;
      animation: pulse 2s infinite;
    }

    /* æ·»åŠ éº¦å…‹é£å›¾æ ‡æ ·å¼ */
    .mic-icon {
      color: #666; /* é»˜è®¤ç°è‰² */
      transition: color 0.3s ease;
      margin-right: 0px !important; /* å‡å°‘å³è¾¹è· */
    }

    .mic-icon.recording {
      color: #28a745; /* å½•éŸ³æ—¶å˜ç»¿è‰² */
    }

    /* ç§»é™¤ stopped ç±»ï¼Œå› ä¸ºé»˜è®¤å°±æ˜¯ç°è‰² */
    .recording-status-dot.stopped {
      background-color: #666;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.2);
        opacity: 0.8;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /*******************************************************
     * 3) #text-editor
     *******************************************************/
    #text-editor {
      width: 100%;
      min-height: 350px; /* Reduce minimum height */
      box-sizing: border-box;
      resize: vertical;      
      overflow: auto;        
      margin: 0 auto;
      background: #fff;      
      border: 2px solid #e2e8f0;
      border-radius: 15px;
      padding: 1.5rem;
      font-size: 1.1rem;
      line-height: 1.6;
      color: #2d3748;
      transition: border-color 0.3s, box-shadow 0.3s;
    }
    #text-editor:focus {
      border-color: #4299e1;
      box-shadow: 0 0 0 3px rgba(66,153,225,0.15);
    }
    #text-editor, 
    #text-editor * {
      outline: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    /*******************************************************
     * 4) Highlight Color: Light Blue
     *******************************************************/
    .highlighted-sentence {
      background-color: #cce7ff;
      transition: background 0.3s;
    }

    /*******************************************************
     * 5) Monitoring / Log: Rounded Corners + Clean
     *******************************************************/
    #mic-status {
      font-weight: bold;
      color: red;
    }
    #mic-status.recording {
      color: #28a745; /* Green */
    }
    #mic-status.recording-active {
      color: #28a745; /* Green */
    }
    #event-log {
      font-size: 0.9rem;
      max-height: 200px;
      overflow-y: auto;
      background: #f9f9f9;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    /*******************************************************
     * 6) Floating Suggestions Box: Modern Style
     *******************************************************/
    .suggestions-box-floating {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.15);
      padding: 6px;
      z-index: 2000;
      user-select: none;
      pointer-events: auto;
      max-height: 160px;
      overflow-y: auto;
      transition: all 0.3s ease;
    }
    .suggestions-box-floating div {
      padding: 10px 12px;
      margin-bottom: 4px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      background-color: rgba(176, 196, 255, 0.2); /* Light blue background */
      border-left: 3px solid rgba(65, 105, 225, 0.5); /* Add a left border */
    }
    .suggestions-box-floating div:nth-child(2n) {
      background-color: rgba(186, 159, 255, 0.2); /* Light purple background */
      border-left: 3px solid rgba(138, 43, 226, 0.5);
    }
    .suggestions-box-floating div:nth-child(3n) {
      background-color: rgba(255, 160, 160, 0.2); /* Light red background */
      border-left: 3px solid rgba(220, 20, 60, 0.5);
    }
    .suggestions-box-floating div:hover {
      transform: translateY(-2px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      background-color: rgba(178, 235, 242, 0.4); /* Slightly darker on hover */
    }
    .suggestions-box-floating div:active {
      transform: translateY(0);
    }

    /*******************************************************
     * 7) Toast: Fixed Bottom Notification
     *******************************************************/
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 12px 24px;
      border-radius: 5px;
      z-index: 3000;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    /*******************************************************
     * 8) Drawer: (Removed old drawer style, replaced by float menu)
     *******************************************************/

    /*******************************************************
     * 9) Tip Card: Colored Left Border + Rounded Corners
     *******************************************************/
    .tip-box {
      background: #f0f2f4; /* Darker background */
      border-left: 4px solid #007bff;
      padding: 12px 16px;
      margin-bottom: 16px;
      border-radius: 4px;
      font-size: 14px;
      color: #495057;
    }
    .tip-content {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 1.1rem;
      font-weight: normal; 
    }
    .tip-content i {
      color: #ffc107;
    }

    /* Enhanced styles for PC */
    @media (min-width: 481px) {
      .tip-content {
        font-size: 1.1rem;
      }
      
      #experience-mode .card {
        padding: 30px;
      }
      
      #experience-undo-button,
      #skip-sentence-button {
        padding: 20px !important;
        font-size: 1.2rem !important;
      }
      
      #target-sentence,
      #error-sentence {
        font-size: 1.3rem;
        line-height: 1.8;
      }
      
      #sentence-index {
        font-size: 1.2rem;
      }
      
      .nav-button {
        padding: 0.7rem 1rem;
        font-size: 1rem;
        border-radius: 10px;
      }
      
      #input-mode .card {
        padding: 50px; /* match Experience Mode card spacing */
      }
      
      #text-editor {
        min-height: 280px;
      }
      
      #monitoring-card p {
        font-size: 1rem;
        margin: 0.7rem 0;
      }
    }

    /* Enhanced styles for Experience Mode Cards (PC Only) */
    @media (min-width: 481px) {
      #experience-mode .card {
        padding: 30px;
      }
      
      /* Adjust button styles */
      #experience-undo-button,
      #skip-sentence-button {
        padding: 20px !important;
        font-size: 1.2rem !important;
      }
      
      /* Adjust target and error sentence fonts */
      #target-sentence,
      #error-sentence {
        font-size: 1.3rem;
        line-height: 1.8;
      }
      
      /* Adjust sentence index style */
      #sentence-index {
        font-size: 1.2rem;
      }
      
      /* Adjust navigation buttons */
      .nav-button {
        padding: 0.7rem 1rem;
        font-size: 1rem;
        border-radius: 10px;
      }
    }

    /* Mobile styles remain unchanged */
    @media (max-width: 480px) {
      .main-content {
        padding: 1rem 0; 
      }
      
      .container {
        width: 94%;
      }
      
      .card {
        padding: 15px;
        margin-bottom: 15px; 
        font-size: 0.9rem; 
      }
      
      .card h3 {
        font-size: 1.1rem;
        margin-bottom: 1rem;
      }

      /* è°ƒæ•´Transcription modeæ ‡é¢˜å¤§å° */
      #experience-mode h3,
      #input-mode h3 {
        font-size: 1.2rem !important;
        margin-bottom: 1rem;
      }
      
      /* ç»Ÿä¸€ç§»åŠ¨ç«¯æŒ‰é’®æ ·å¼ */
      .mode-button,
      #experience-undo-button,
      #skip-sentence-button,
      #next-pair-button,
      #simple-undo-button,
      .clear-button {
        padding: 8px 12px !important;
        font-size: 0.9rem !important;
        border-radius: 6px !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        transition: all 0.2s ease !important;
      }

      /* ç‰¹åˆ«å¤„ç† Next Sentence æŒ‰é’®æ ·å¼ */
      #skip-sentence-button {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        min-height: 36px !important;
        text-align: center !important;
        line-height: 1.2 !important;
      }

      #skip-sentence-button:not([style*="background: #6c757d"]) {
        background: #007bff !important;
        color: #fff !important;
        cursor: pointer !important;
      }

      #skip-sentence-button[style*="background: #6c757d"] {
        background: #6c757d !important;
        color: #fff !important;
        cursor: default !important;
        opacity: 0.7 !important;
      }

      /* è°ƒæ•´å»ºè®®æ¡†æ ·å¼ */
      .suggestions-box-floating {
        max-width: 90vw !important;
        width: auto !important;
        font-size: 1.0rem !important;
      }

      .suggestions-box-floating div {
        padding: 8px 10px !important;
        margin-bottom: 3px !important;
        line-height: 1.5 !important;
      }

      /* è°ƒæ•´å¯¼èˆªæŒ‰é’®æ ·å¼ */
      .nav-button {
        padding: 6px 10px !important;
        font-size: 0.9rem !important;
      }
      
      #text-editor {
        min-height: 200px;
        padding: 1rem;
        font-size: 1rem;
        line-height: 1.5;
      }
      
      #monitoring-card p {
        font-size: 0.9rem;
        margin: 0.5rem 0;
      }
      
      #event-log {
        font-size: 0.85rem;
        max-height: 150px;
      }
      
      #mode-buttons {
        margin-bottom: 15px; 
        gap: 10px;
      }

      /* è°ƒæ•´æ¸…é™¤æŒ‰é’®æ ·å¼ */
      .clear-button {
        padding: 4px 10px !important;
        font-size: 0.85rem !important;
      }

      /* è°ƒæ•´è‡ªç”±è¾“å…¥æ¨¡å¼ä¸‹çš„ Undo æŒ‰é’®é«˜åº¦ */
      #simple-undo-button {
        min-height: 36px !important;
      }

      /* è°ƒæ•´é”™è¯¯å¥å­å’Œç›®æ ‡å¥å­çš„å­—ä½“å¤§å° */
      #target-sentence {
        font-size: 1.1rem !important;
        line-height: 1.6 !important;
      }

      #error-sentence {
        font-size: 1.2rem !important;
        line-height: 1.6 !important;
      }

      /* è°ƒæ•´å»ºè®®æ¡†çš„å­—ä½“å¤§å° */
      .suggestions-box-floating {
        max-width: 90vw !important;
        width: auto !important;
        font-size: 1.0rem !important;
      }

      .suggestions-box-floating div {
        padding: 8px 10px !important;
        margin-bottom: 3px !important;
        line-height: 1.5 !important;
      }
    }

    /* Base styles for navigation buttons */
    .nav-button {
      padding: 0.7rem 1rem;
      border: none;
      border-radius: 8px;
      background: #007bff;
      box-shadow: 0 2px 6px rgba(0,123,255,0.3);
      cursor: pointer;
      color: #ffffff;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    .nav-button:hover {
      background: #0056b3;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,123,255,0.4);
    }

    .nav-button:active {
      transform: translateY(0);
      background: #004494;
      box-shadow: 0 2px 4px rgba(0,123,255,0.2);
    }

    /*******************************************************
     * New: Error sentence text box style
     *******************************************************/
    .editable-sentence-box {
      width: 100%;
      min-height: 150px; 
      padding: 12px 15px;
      background: #f8f9fa;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 1.1rem;
      line-height: 1.6;
      cursor: text;
      transition: all 0.2s ease;
      box-sizing: border-box; 
      
      /* Enhanced text selection disabling for experience mode */
      user-select: none !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-user-drag: none !important;
      pointer-events: auto !important;
    }
    
    .editable-sentence-box:hover {
      background: #f1f3f5;
      border-color: #cbd5e0;
    }
    
    .editable-sentence-box.active {
      border-color: #4299e1;
      box-shadow: 0 0 0 3px rgba(66,153,225,0.15);
    }
    
    .edit-indicator {
      display: inline-block;
      margin-left: 8px;
      font-size: 0.8rem;
      color: #666;
      font-style: italic;
    }

    /*******************************************************
     * New: Cursor feedback at click position
     *******************************************************/
    .cursor-indicator {
      display: inline-block;
      width: 2px;
      height: 1.5em; 
      background-color: #E6B422;
      animation: blink 1s infinite;
      position: absolute;
      z-index: 10;
      pointer-events: none; 
      margin-top: 0; 
      border-radius: 1px; 
      box-shadow: 0 0 3px rgba(230, 180, 34, 0.5);
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    .dragging {
      cursor: text !important;
      user-select: none !important;
      -webkit-user-select: none !important;
    }

    /* Only enable text selection if .dragging is applied with higher priority */
    .editable-sentence-box.dragging {
      cursor: text !important;
      user-select: text !important;
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      -ms-user-select: text !important;
    }

    /* Prevent iOS from text selection on long-press in experience mode */
    @media (hover: none) {
      .editable-sentence-box {
        touch-action: manipulation; 
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
      
      /* ç‰¹æ®Šå¤„ç†è‡ªç”±è¾“å…¥æ¨¡å¼ */
      #simple-editor {
        touch-action: manipulation;
        -webkit-user-select: text;
        user-select: text;
      }
      
      /* çŸ­æŒ‰æ—¶æ¢å¤é€‰æ‹©åŠŸèƒ½ */
      #simple-editor:focus {
        -webkit-user-select: text;
        user-select: text;
      }
    }

    /* Animation keyframes for long-press feedback */
    @keyframes pulsate {
      0% { transform: scale(0.8); opacity: 0.7; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    /* åˆ é™¤åŸæ¥çš„ drawer æ ·å¼,æ·»åŠ æ–°çš„æ‚¬æµ®æŒ‰é’®å’Œèœå•æ ·å¼ */
    #float-menu-button {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      border-radius: 25px;
      background: #007bff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.3s ease;
      z-index: 3000;
    }

    #float-menu-button:hover {
      transform: scale(1.1);
      background: #0056b3;
    }

    #float-menu {
      position: fixed;
      bottom: 80px;
      left: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      padding: 8px;
      display: none;
      flex-direction: column;
      gap: 8px;
      z-index: 3000;
      min-width: 180px;
    }

    #float-menu button {
      padding: 10px 15px;
      border: none;
      border-radius: 8px;
      background: #f8f9fa;
      color: #495057;
      cursor: pointer;
      text-align: left;
      font-size: 0.9rem;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #float-menu button:hover {
      background: #e9ecef;
      transform: translateX(5px);
    }

    #float-menu button i {
      font-size: 1.1rem;
      color: #007bff;
    }

    /* æ·»åŠ æ¸…é™¤æŒ‰é’®æ ·å¼ */
    .clear-button {
      padding: 4px 12px;
      font-size: 0.9rem;
      border: none;
      border-radius: 4px;
      background: #dc3545;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-left: auto;
    }
    .clear-button:hover {
      background: #c82333;
      transform: translateY(-1px);
    }
    .clear-button:active {
      transform: translateY(0);
    }
    
    /* è°ƒæ•´æ ‡é¢˜è¡Œæ ·å¼ä»¥å®¹çº³æŒ‰é’® */
    .card h3 {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 1.2rem;
    }

    /* æ·»åŠ ç¦ç”¨çŠ¶æ€çš„æ ·å¼ */
    #simple-undo-button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    /* åˆ é™¤å…¶ä»–å¤æ‚æ ·å¼ */
    #simple-undo-button {
      margin-top: 12px;
      width: 100%;
      padding: 20px;
      font-size: 20px;
      border: none;
      border-radius: 6px;
      background: #28a745;
      color: #fff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Header Load -->
  <header id="header-container"></header>

  <!-- Main Content -->
  <div class="main-content">
    <div class="container">
      <!-- Mode Switch Buttons -->
      <div id="mode-buttons">
        <button id="mode-experience" class="mode-button active">Transcription Mode</button>
        <button id="mode-input" class="mode-button">Free-input Mode</button>
      </div>
    </div>

    <!-- Monitoring Area -->
    <div class="container">
      <div class="card" id="monitoring-card">
        <p><strong>Erroneous Sentence:</strong> <span id="error-text">None</span></p>
        <p><strong>Touch Location (character index):</strong> <span id="touch-index">None</span></p>
        <p><strong>Correction Command:</strong> <span id="final-output">None</span></p>
        <p><strong>Recording Status:</strong> <span id="mic-status">ğŸ”´ Stopped</span></p>
        <p style="display:none;"><strong>Original Error Sentence:</strong> <span id="original-error-sentence">None</span></p>
        <p style="display:none;"><strong>Speech Input:</strong> <span id="voice-input">None</span></p>
      </div>
    </div>

    <!-- ============ Transcription Mode ============ -->
    <div class="container">
      <div class="card" id="experience-mode">
        <h3>Transcription Mode <i class="fas fa-microphone mic-icon"></i><span class="recording-status-dot"></span></h3>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
            <button class="nav-button" id="prev-sentence" style="visibility:hidden;">â†</button>
            <span id="sentence-index">1/5</span>
            <button class="nav-button" id="next-sentence">â†’</button>
          </div>
          <div>
            <p><strong>Target Sentence:</strong></p>
            <div id="target-sentence" style="user-select:none; margin-bottom: 15px;"></div>
          </div>
          <p><strong>Erroneous Sentence:</strong> <span class="edit-indicator"></span></p>
          <div id="error-sentence" class="editable-sentence-box"></div>
          <div style="display:flex;gap:10px;margin-top:12px;">
            <button id="experience-undo-button" style="
              flex:1;
              padding:20px;
              font-size:20px;
              border:none;
              border-radius:6px;
              background:#28a745;
              color:#fff;
              box-shadow:0 2px 6px rgba(0,0,0,0.2);
              cursor:pointer;
            ">Restore Error Sentence</button>
            <button id="skip-sentence-button" style="
              flex:1;
              padding:20px;
              font-size:20px;
              border:none;
              border-radius:6px;
              background:#6c757d;
              color:#fff;
              box-shadow:0 2px 6px rgba(0,0,0,0.2);
              cursor:pointer;
            ">Next Sentence</button>
          </div>
          <button id="next-pair-button" style="
            width:100%;
            margin-top:10px;
            padding:20px;
            font-size:20px;
            border:none;
            border-radius:6px;
            background:#007bff;
            color:#fff;
            box-shadow:0 2px 6px rgba(0,0,0,0.2);
            cursor:pointer;
            display:none;
          ">Next Sentence</button>
        </div>
      </div>
    </div>

    <!-- ============ Free Input Mode ============ -->
    <div class="container">
      <div class="card" id="input-mode" style="display:none;">
        <h3>
          Free-Input Mode 
          <i class="fas fa-microphone mic-icon"></i>
          <span class="recording-status-dot"></span>
          <button class="clear-button" id="clear-text-button">Clear</button>
        </h3>
        <div id="simple-editor" contenteditable="true" style="
          width: 100%;
          min-height: 401px;
          box-sizing: border-box;
          resize: vertical;      
          overflow: auto;        
          margin: 0 auto;
          background: #fff;      
          border: 2px solid #e2e8f0;
          border-radius: 15px;
          padding: 1.5rem;
          font-size: 1.1rem;
          line-height: 1.6;
          color: #2d3748;
          transition: border-color 0.3s, box-shadow 0.3s;
          white-space: pre-wrap;
          word-wrap: break-word;
          cursor: text;
        ">Try to tap on Wednesday till the mic icon is green, then speak 'on Tuesday'.
Or you can clear the text using the clear button and input your own text.

Hi, how are you? Meet me on Wednesday. us household.</div>
        
        <button id="simple-undo-button" style="
          margin-top:12px;
          width:100%;
          padding:20px;
          font-size:20px;
          border:none;
          border-radius:6px;
          background:#28a745;
          color:#fff;
          box-shadow:0 2px 6px rgba(0,0,0,0.2);
          cursor:pointer;
        ">Undo Last Change</button>
      </div>
    </div>

    <!-- Event Log Area -->
    <div class="container">
      <div class="card" id="event-log-card">
        <h3>Event Log</h3>
        <div id="event-log">No events recorded</div>
      </div>
    </div>
  </div>

  <!-- Footer Load -->
  <footer id="footer-container"></footer>

  <!-- æ–°çš„æ‚¬æµ®æŒ‰é’®å’Œèœå• -->
  <button id="float-menu-button">
    <!-- å›¾æ ‡åœ¨JSä¸­ä¼šæ›¿æ¢æˆsvg -->
  </button>
  <div id="float-menu"></div>

  <script>
    /***********************************************
     * ============ A) é€šç”¨ç•Œé¢ & é€šç”¨ä»£ç  ============
     ***********************************************/
    const API_URL = "https://tns.zacchen.win/correct";
    const PUNCTUATION_API_URL = "https://tns.zacchen.win/restore_punctuation";

    // Two Mode Constants
    const MODE_EXPERIENCE = "experience";
    const MODE_INPUT = "input";
    let activeMode = MODE_EXPERIENCE; // default

    // å…¨å±€å˜é‡
    let disableIME = false;
    let isListening = false;
    let isRecording = false;
    let recognition = null;
    let silenceTimer = null;
    let globalTapIndex = -1;
    let localTapIndex = -1;
    let tapStartIndex = -1;
    let originalSentence = "";
    let lastHighlightedSentence = "";
    let highlightTimeout = null;
    let suggestionsBox = null;
    let suggestionsTimer = null;
    let undoStack = [];
    let isDragging = false;
    let cursorElement = null;
    let cursorTimeout = null;
    let selectedSentence = ""; // åœ¨Transcriptionæ¨¡å¼ä½¿ç”¨ï¼Œä¹Ÿä¼šè¢«ä¸€äº›é€šç”¨å‡½æ•°å¼•ç”¨
    let isDraggingAndRecording = false; // æ–°å¢å˜é‡ï¼Œç”¨äºæ ‡è®°æ‹–åŠ¨+å½•éŸ³çŠ¶æ€
    let useWebkitSpeech = true;
    let maxRecordingTime = 20000; // æœ€å¤§å½•éŸ³æ—¶é—´ï¼Œé»˜è®¤10ç§’
    let currentSentenceInfo = null; // å­˜å‚¨å½“å‰å¥å­çš„è¯¦ç»†ä¿¡æ¯

    // DOM Elements
    const monitoringCard = document.getElementById("monitoring-card");
    const eventLogCard = document.getElementById("event-log-card");
    const errorText = document.getElementById("error-text");
    const originalErrorSpan = document.getElementById("original-error-sentence");
    const touchIndexSpan = document.getElementById("touch-index");
    const voiceInputSpan = document.getElementById("voice-input");
    const micStatusSpan = document.getElementById("mic-status");
    const finalOutputSpan = document.getElementById("final-output");
    const eventLog = document.getElementById("event-log");
    
    // UIæŒ‰é’®å¼•ç”¨
    const modeExperienceBtn = document.getElementById("mode-experience");
    const modeInputBtn = document.getElementById("mode-input");

    // ç»éªŒæ¨¡å¼ & è‡ªç”±æ¨¡å¼ å®¹å™¨
    const modeExperienceContainer = document.getElementById("experience-mode");
    const modeInputContainer = document.getElementById("input-mode");

    /*******************************************************
     * Universal: Toast / Event Log / IME toggle
     *******************************************************/
    function logEvent(message) {
      const p = document.createElement("p");
      const now = new Date().toLocaleString("en-US", {hour12: false});
      p.innerText = `[${now}] ${message}`;
      eventLog.appendChild(p);
    }
    function updateIMEButtonText(enabled) {
      const button = document.getElementById('toggle-ime');
      if (button) {
        button.textContent = enabled ? 'Disable IME' : 'Enable IME';
      }
    }

    /*******************************************************
     * Universal: remove punctuation
     *******************************************************/
    function removePunctuation(str) {
      return str.replace(/[^a-zA-Z0-9'\s]/g, "");
    }

    /*******************************************************
     * Universal: å¥å­ä¸‹åˆ’çº¿
     *******************************************************/
    function underlineDiffRanges(text, diffRanges) {
      let result = "";
      let currentIndex = 0;
      const validRanges = diffRanges.filter(range => 
        range[0] >= 0 && range[0] < text.length && range[1] > 0 && range[1] <= text.length
      );
      
      validRanges.forEach(function(range) {
        let [start, end] = range;
        end = Math.min(end, text.length);
        
        let diffText = text.substring(start, end);
        let leadingSpaceMatch = diffText.match(/^(\s+)/);
        let leadingSpaceLength = leadingSpaceMatch ? leadingSpaceMatch[0].length : 0;
        
        result += text.substring(currentIndex, start);
        
        if (leadingSpaceLength > 0) {
          result += diffText.substring(0, leadingSpaceLength);
          if (leadingSpaceLength < diffText.length) {
            result += '<span style="border-bottom: 2px solid blue;">'
                      + diffText.substring(leadingSpaceLength) + '</span>';
          }
        } else {
          result += '<span style="border-bottom: 2px solid blue;">' + diffText + '</span>';
        }
        
        currentIndex = end;
      });
      result += text.substring(currentIndex);
      return result;
    }

    /*******************************************************
     * Universal: é€šç”¨æ›¿æ¢å‡½æ•°
     *******************************************************/
    function replaceFirstOccurrence(fullText, oldPart, newPart) {
      let safe = oldPart.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      let reg = new RegExp(safe, "i");
      return fullText.replace(reg, newPart);
    }

    /*******************************************************
     * Universal: ç§»é™¤å…‰æ ‡
     *******************************************************/
    function removeCursor() {
      if (cursorTimeout) {
        clearTimeout(cursorTimeout);
        cursorTimeout = null;
      }
      if (cursorElement) {
        cursorElement.remove();
        cursorElement = null;
      }
    }

    /*******************************************************
     * Universal: Suggestions Box ç§»é™¤
     *******************************************************/
    function removeSuggestionsBox() {
      if (suggestionsBox) {
        suggestionsBox.remove();
        suggestionsBox = null;
      }
    }

    /*******************************************************
     * Universal: åŒæ­¥åˆ°åç«¯ /correct API å¹¶å¤„ç†å›ä¼ 
     *******************************************************/
    function sendToAPI(mergedStr, loc, isExperienceMode) {
      let finalLoc = parseInt(loc, 10) || 0;
      logEvent(`Sending /correct => merged_string:${mergedStr}, touch_location:${finalLoc}, isExpMode:${isExperienceMode}`);
      fetch(API_URL, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ merged_string: mergedStr, touch_location: finalLoc })
      })
      .then(resp => resp.json())
      .then(data => {
        let corrs = data.filtered_corrections || [];
        logEvent("API corrections => " + JSON.stringify(corrs));
        applyFirstSuggestionAndShowBox(corrs, isExperienceMode);
      })
      .catch(err => {
        logEvent("API call error => " + err);
      });
    }

    /*******************************************************
     * Universal: åº”ç”¨ç¬¬ä¸€ä¸ªå»ºè®®å¹¶å±•ç¤ºé¢å¤–é€‰é¡¹
     * æ³¨æ„ï¼šåé¢ä¼šè¢«Transcriptionæ¨¡å¼ & Free-inputæ¨¡å¼è¦†ç›–ä½¿ç”¨
     *******************************************************/
    function applyFirstSuggestionAndShowBox(corrections, isExperienceMode) {
      // è¿™éƒ¨åˆ†åœ¨åé¢ä¼šè¢«Transcriptionæ¨¡å¼ & è‡ªç”±è¾“å…¥æ¨¡å¼å„è‡ªé€»è¾‘è¿›è¡Œ"åˆå¹¶"æˆ–"è¦†ç›–"
      // å…ˆå ä½ï¼Œåé¢æœ‰åŸå§‹çš„å®ç°ä¼šå†æ¬¡è¦†ç›–è¿™ä¸ªæ–¹æ³•
    }

    /*******************************************************
     * Universal: Speech Recognition
     *******************************************************/
    function startRecording(dontProcessResults = false) {
      if (isRecording) {
        console.log("Already recording");
        return;
      }

      // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„åœæ­¢å½•éŸ³å®šæ—¶å™¨
      if (window.stopRecordingTimer) {
        clearTimeout(window.stopRecordingTimer);
        window.stopRecordingTimer = null;
      }

      // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
      if (voiceInputSpan) voiceInputSpan.innerText = "";
      
      if (!("SpeechRecognition" in window) && !("webkitSpeechRecognition" in window)) {
        console.warn("Speech recognition not supported in this browser.");
        return;
      }
      
      isRecording = true;
      isListening = true;

      micStatusSpan.innerHTML = "ğŸŸ¢ Recording...";
      micStatusSpan.className = "recording-active";

      // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºåœ†ç‚¹å’Œéº¦å…‹é£å›¾æ ‡
      const dots = document.querySelectorAll('.recording-status-dot');
      const micIcons = document.querySelectorAll('.mic-icon');
      dots.forEach(dot => {
        dot.classList.remove('stopped');
        dot.classList.add('recording');
      });
      micIcons.forEach(icon => {
        icon.classList.add('recording');
      });

      try {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.lang = 'en-US';
        recognition.interimResults = true;
        recognition.continuous = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => {
          isRecording = true;
          isListening = true;
          clearTimeout(silenceTimer);
          silenceTimer = setTimeout(() => {
            if (recognition && isRecording) {
              try { recognition.stop(); } catch (e) { console.error(e); }
            }
          }, 5000);
        };

        recognition.onresult = (event) => {
          clearTimeout(silenceTimer);
          const transcript = Array.from(event.results).map(r => r[0].transcript).join('');
          voiceInputSpan.innerText = transcript;
          finalOutputSpan.innerText = transcript;

          if (!event.results[0].isFinal && recognition) {
            setTimeout(() => {
              try { recognition.stop(); } catch (e) { console.error(e); }
            }, 800);
          }
        };

        recognition.onend = () => {
          clearTimeout(silenceTimer);
          isRecording = false;
          isListening = false;
          micStatusSpan.innerHTML = "ğŸ”´ Stopped";
          micStatusSpan.className = "";
          removeCursor();

          // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºåœ†ç‚¹å’Œéº¦å…‹é£å›¾æ ‡
          const dots = document.querySelectorAll('.recording-status-dot');
          const micIcons = document.querySelectorAll('.mic-icon');
          dots.forEach(dot => {
            dot.classList.remove('recording');
          });
          micIcons.forEach(icon => {
            icon.classList.remove('recording');
          });

          if (voiceInputSpan.innerText.trim()) {
            setTimeout(finalizeTapSay, 100);
          } else {
            endTapSay();
          }
        };

        recognition.onerror = (event) => {
          console.error("[Global] recognition error =>", event.error);
          clearTimeout(silenceTimer);
          isRecording = false;
          isListening = false;
          micStatusSpan.innerHTML = "ğŸ”´ Error";
          micStatusSpan.className = "";
          removeCursor();

          // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºåœ†ç‚¹å’Œéº¦å…‹é£å›¾æ ‡
          const dots = document.querySelectorAll('.recording-status-dot');
          const micIcons = document.querySelectorAll('.mic-icon');
          dots.forEach(dot => {
            dot.classList.remove('recording');
          });
          micIcons.forEach(icon => {
            icon.classList.remove('recording');
          });

          endTapSay();
        };

        recognition.start();
      } catch (e) {
        isRecording = false;
        isListening = false;
        micStatusSpan.innerHTML = "ğŸ”´ Error";
        micStatusSpan.className = "";
        removeCursor();

        // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºåœ†ç‚¹å’Œéº¦å…‹é£å›¾æ ‡
        const dots = document.querySelectorAll('.recording-status-dot');
        const micIcons = document.querySelectorAll('.mic-icon');
        dots.forEach(dot => {
          dot.classList.remove('recording');
        });
        micIcons.forEach(icon => {
          icon.classList.remove('recording');
        });
      }
    }

    function endTapSay() {
      clearTimeout(highlightTimeout);
      clearTimeout(silenceTimer);
      if (recognition) {
        try {
          recognition.onend = null;
          recognition.abort();
        } catch(e) {
          console.error("[Global] endTapSay => error stopping:", e);
        }
        recognition = null;
      }
      isRecording = false;
      isListening = false;
      micStatusSpan.innerHTML = "ğŸ”´ Stopped";
      micStatusSpan.className = "";
      removeCursor();
      voiceInputSpan.innerText = "";

      // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºåœ†ç‚¹å’Œéº¦å…‹é£å›¾æ ‡
      const dots = document.querySelectorAll('.recording-status-dot');
      const micIcons = document.querySelectorAll('.mic-icon');
      dots.forEach(dot => {
        dot.classList.remove('recording');
      });
      micIcons.forEach(icon => {
        icon.classList.remove('recording');
      });
    }

    /*******************************************************
     * Universal: finalizeTapSay
     * å½“ speech recognition ç»“æŸåï¼ŒæŠŠç»“æœå‘å¾€ API
     *******************************************************/
    function finalizeTapSay() {
      const transcript = (voiceInputSpan.innerText || "").trim();
      if (!transcript) {
        endTapSay();
        return;
      }
      let parted = errorText.innerText.trimEnd();
      parted = parted.replace(/([.!?])(\S)/g, "$1 $2");
      let textNoPunc = removePunctuation(transcript).trimEnd();
      let merged = (parted + " <||> " + textNoPunc).trimEnd();
      finalOutputSpan.innerText = textNoPunc;

      let finalIndex = (activeMode === MODE_INPUT) ? localTapIndex :
                       (tapStartIndex !== -1 ? tapStartIndex : localTapIndex);

      sendToAPI(merged, finalIndex, activeMode === MODE_EXPERIENCE);
      voiceInputSpan.innerText = "";
      lastHighlightedSentence = errorText.innerText;
      tapStartIndex = -1;

      clearTimeout(highlightTimeout);
      highlightTimeout = setTimeout(() => {
        removeCursor();
      }, 3000);
    }

    /***********************************************
     * ============ B) Transcription Mode ä»£ç  ============
     ***********************************************/
    // Transcriptionæ¨¡å¼æ‰€éœ€æ•°æ®
    let currentPairIndex = 0;
    const sentencePairs = [
      {
        target: "Your best bet is to drop him and go after another player.",
        error: "Your best bet is to drop him and go after another.",
        tip: "Tap near the mistake till the mic icon is green, then speak correction. Here's like 'another player'."
      },
      {
        target: "Energy consumption trends in US households are shifting rapidly.",
        error: "Energy consumption trends in us household are shifting rapidly.",
        tip: "Great! It also works on capitalization issues along the way. Here try 'US households'."
      },
      {
        target: "She has been living in Paris for the past five years.",
        error: "She has lived in Paris since five years.",
        tip: "Multiple mistakes can be corrected multiple times"
      },
      {
        target: "The cat sat on the mat. The dog chased the cat. The mouse ran away quickly.",
        error: "The cat sat on the mat. The dog chase the cat. The mouse ran away quickly.",
        tip: "This also works for multi-sentence paragraphs"
      },
      {
        target: "They were discussing the implications of the new policy.",
        error: "They were discuss about the implications of the new policy.",
        tip: "If the first suggestion isn't correct, pick another from the list"
      }
    ];

    /*******************************************************
     * Transcription: åˆå§‹åŒ– Experience Mode
     *******************************************************/
    function initializeExperienceMode() {
      updateSentencePair(0);
      attachExpListeners();
    }

    /*******************************************************
     * Transcription: ä¸ºé”™è¯¯å¥å­ç»‘å®šé•¿æŒ‰ã€æ‹–åŠ¨ã€ç‚¹å‡»ç­‰äº‹ä»¶
     *******************************************************/
    function attachExpListeners() {
      const prev = document.getElementById("prev-sentence");
      const next = document.getElementById("next-sentence");
      const skip = document.getElementById("skip-sentence-button");
      const nextPair = document.getElementById("next-pair-button");
      const expUndo = document.getElementById("experience-undo-button");
      const errorSentenceEl = document.getElementById("error-sentence");
      if (!prev || !next || !skip || !nextPair || !expUndo || !errorSentenceEl) return;

      // å–æ¶ˆé»˜è®¤çš„å³é”®èœå•å’ŒåŒå‡»é€‰æ‹©
      errorSentenceEl.addEventListener('contextmenu', e => {
        e.preventDefault();
        return false;
      });
      errorSentenceEl.addEventListener('dblclick', e => {
        e.preventDefault();
        return false;
      });
      errorSentenceEl.addEventListener('selectstart', e => {
        if (!isDragging) {
          e.preventDefault();
          return false;
        }
      });

      prev.addEventListener("click", () => {
        if (currentPairIndex > 0) {
          currentPairIndex--;
          updateSentencePair(currentPairIndex);
        }
      });
      next.addEventListener("click", () => {
        if (currentPairIndex < sentencePairs.length - 1) {
          currentPairIndex++;
          updateSentencePair(currentPairIndex);
        }
      });
      skip.addEventListener("click", () => {
        if (currentPairIndex < sentencePairs.length - 1) {
          currentPairIndex++;
          updateSentencePair(currentPairIndex);
          console.log("Skipped current sentence");
        } else {
          console.log("This is the last sentence");
        }
      });
      nextPair.addEventListener("click", () => {
        if (currentPairIndex < sentencePairs.length - 1) {
          currentPairIndex++;
          updateSentencePair(currentPairIndex);
        } else {
          console.log("All sentences completed!");
        }
      });
      expUndo.addEventListener("click", () => {
        const errorSentenceEl = document.getElementById("error-sentence");
        if (!errorSentenceEl) return;
        
        const originalErrorSentence = sentencePairs[currentPairIndex].error;
        errorSentenceEl.innerText = originalErrorSentence;
        
        // é‡ç½®é€‰ä¸­å¥
        selectedSentence = "";
        
        // é‡ç½®SkipæŒ‰é’®
        const skipBtn = document.getElementById("skip-sentence-button");
        if (skipBtn) {
          skipBtn.textContent = "Next Sentence";
          skipBtn.style.background = "#6c757d";
          skipBtn.style.opacity = "0.7";
          skipBtn.style.pointerEvents = "none";
          skipBtn.style.cursor = "default";
        }
        
        errorSentenceEl.style.background = "";
        errorSentenceEl.style.borderColor = "";
        logEvent("Restored to original error sentence");
      });

      attachTranscriptionLongPress(errorSentenceEl);
    }

    /*******************************************************
     * Transcription: é•¿æŒ‰å¹¶æ‹–æ‹½é€‰å–æ–‡å­—
     *******************************************************/
    function attachTranscriptionLongPress(errorSentenceEl) {
      let pressTimerExp = null;
      let longPressStarted = false;
      let longPressThreshold = 100;
      let isDraggingAndRecording = false;
      let stopRecordingTimer = null;  // æ·»åŠ ä¸€ä¸ªå®šæ—¶å™¨æ¥å»¶è¿Ÿåœæ­¢å½•éŸ³

      // ä¿®æ”¹recognitionçš„onresultå¤„ç†
      if (recognition) {
        recognition.onresult = (event) => {
          clearTimeout(silenceTimer);
          const transcript = Array.from(event.results).map(r => r[0].transcript).join('');
          voiceInputSpan.innerText = transcript;
          finalOutputSpan.innerText = transcript;

          // å¦‚æœæ˜¯æ‹–æ‹½æ¨¡å¼ï¼Œä½¿ç”¨å½“å‰å…‰æ ‡ä½ç½®æ›´æ–°é€‰ä¸­çš„å¥å­
          if (isDraggingAndRecording) {
            const text = errorSentenceEl.innerText;
            const currentSentence = getCurrentSentenceForTranscription(text, localTapIndex);
            errorText.innerText = currentSentence;
            originalSentence = currentSentence;
            originalErrorSpan.innerText = currentSentence;
            selectedSentence = currentSentence;
          }

          if (!event.results[0].isFinal && recognition) {
            setTimeout(() => {
              try { recognition.stop(); } catch (e) { console.error(e); }
            }, 800);
          }
        };
      }

      errorSentenceEl.addEventListener("mousedown", (e) => {
        // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„åœæ­¢å½•éŸ³å®šæ—¶å™¨
        if (stopRecordingTimer) {
          clearTimeout(stopRecordingTimer);
          stopRecordingTimer = null;
        }

        if (isDragging) return;
        removeCursor();

        const rect = e.currentTarget.getBoundingClientRect();
        const text = errorSentenceEl.innerText;
        
        // ä½¿ç”¨ caretRangeFromPoint æ¥è·å–ç²¾ç¡®çš„ä½ç½®
        const x = e.clientX;
        const y = e.clientY;
        if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(x, y);
          if (range) {
            localTapIndex = range.startOffset;
          }
        } else {
          // å›é€€æ–¹æ¡ˆ
          const style = window.getComputedStyle(errorSentenceEl);
          const fontSize = parseFloat(style.fontSize);
          const paddingLeft = parseFloat(style.paddingLeft);
          const clickX = e.clientX - rect.left - paddingLeft;
          const averageCharWidth = fontSize * 0.6;
          localTapIndex = Math.round(clickX / averageCharWidth);
        }
        localTapIndex = Math.max(0, Math.min(text.length, localTapIndex));

        // å¼€å§‹å½•éŸ³ï¼ˆæ— è®ºæ˜¯ç‚¹å‡»è¿˜æ˜¯é•¿æŒ‰ï¼‰
        startRecording();

        // è·å–å½“å‰ä½ç½®å¯¹åº”çš„å¥å­ä¿¡æ¯
        const sentenceInfo = getCurrentSentenceForTranscription(text, localTapIndex);
        errorText.innerText = sentenceInfo.sentence;
        originalSentence = sentenceInfo.sentence;
        originalErrorSpan.innerText = sentenceInfo.sentence;
        selectedSentence = sentenceInfo.sentence;
        
        // ä¿å­˜å¥å­ä¿¡æ¯ï¼ŒåŒ…æ‹¬ç›¸å¯¹ä½ç½®
        currentSentenceInfo = sentenceInfo;
        // è®°å½•ç›¸å¯¹ä½ç½®ï¼Œç”¨äºfinalizeTapSay
        tapStartIndex = sentenceInfo.relativePosition;
        console.log("Mouse down - Relative position set to:", sentenceInfo.relativePosition);

        pressTimerExp = setTimeout(() => {
          longPressStarted = true;
          isDraggingAndRecording = true;
          handleExpLongPress();
          showLongPressFeedback(e.clientX, e.clientY);
        }, longPressThreshold);
      });

      errorSentenceEl.addEventListener("mousemove", () => {
        if (pressTimerExp && !longPressStarted) {
          clearTimeout(pressTimerExp);
          pressTimerExp = null;
        }
      });

      errorSentenceEl.addEventListener("mouseup", () => {
        clearTimeout(pressTimerExp);
        pressTimerExp = null;
        longPressStarted = false;
        if (isDraggingAndRecording) {
          isDraggingAndRecording = false;
          isDragging = false;
          errorSentenceEl.classList.remove("dragging");
          
          // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if (stopRecordingTimer) {
            clearTimeout(stopRecordingTimer);
          }
          
          // è®¾ç½®3ç§’ååœæ­¢å½•éŸ³
          stopRecordingTimer = setTimeout(() => {
            if (recognition) {
              try {
                recognition.stop();
              } catch (ex) {
                console.error("[Transcription] error stopping:", ex);
              }
            }
          }, 3000);
        }
      });

      // touch events
      errorSentenceEl.addEventListener("touchstart", (e) => {
        // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„åœæ­¢å½•éŸ³å®šæ—¶å™¨
        if (stopRecordingTimer) {
          clearTimeout(stopRecordingTimer);
          stopRecordingTimer = null;
        }

        if (isDragging) return;
        removeCursor();
        
        // æ¸…é™¤å¯èƒ½å·²æœ‰çš„é€‰æ‹©
        const selection = window.getSelection();
        selection.removeAllRanges();

        const touch = e.touches[0];
        const rect = e.currentTarget.getBoundingClientRect();
        const text = errorSentenceEl.innerText;
        
        if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(touch.clientX, touch.clientY);
          if (range) {
            localTapIndex = range.startOffset;
          }
        } else {
          // å›é€€æ–¹æ¡ˆ
          const style = window.getComputedStyle(errorSentenceEl);
          const fontSize = parseFloat(style.fontSize);
          const paddingLeft = parseFloat(style.paddingLeft);
          const touchX = touch.clientX - rect.left - paddingLeft;
          const averageCharWidth = fontSize * 0.6;
          localTapIndex = Math.round(touchX / averageCharWidth);
        }
        localTapIndex = Math.max(0, Math.min(text.length, localTapIndex));

        // å¼€å§‹å½•éŸ³ï¼ˆæ— è®ºæ˜¯ç‚¹å‡»è¿˜æ˜¯é•¿æŒ‰ï¼‰
        startRecording();

        // å¯¹äºå•å‡»ï¼Œç›´æ¥ä½¿ç”¨å½“å‰ä½ç½®é€‰æ‹©å¥å­
        const currentSentence = getCurrentSentenceForTranscription(text, localTapIndex);
        errorText.innerText = currentSentence.sentence;
        originalSentence = currentSentence.sentence;
        originalErrorSpan.innerText = currentSentence.sentence;
        selectedSentence = currentSentence.sentence;
        
        // ä¿å­˜å½“å‰å¥å­ä¿¡æ¯
        currentSentenceInfo = currentSentence;
        // è®°å½•ç›¸å¯¹ä½ç½®ï¼Œç”¨äºfinalizeTapSay
        tapStartIndex = currentSentence.relativePosition;
        console.log("Touch start - Relative position set to:", currentSentence.relativePosition);

        // è®¾ç½®æ ‡å¿—ï¼Œé˜²æ­¢iOSé»˜è®¤çš„æ–‡æœ¬é€‰æ‹©
        errorSentenceEl.dataset.touchStarted = "true";
        // ç¦ç”¨iOSçš„é•¿æŒ‰é€‰æ‹©è¡Œä¸º
        e.preventDefault();

        pressTimerExp = setTimeout(() => {
          if (errorSentenceEl.dataset.touchStarted === "true") {
            longPressStarted = true;
            isDraggingAndRecording = true;
            handleExpLongPress();
            showLongPressFeedback(touch.clientX, touch.clientY);
          }
        }, longPressThreshold);
      });

      errorSentenceEl.addEventListener("touchend", () => {
        if (errorSentenceEl.dataset.touchStarted) {
          delete errorSentenceEl.dataset.touchStarted;
        }
        clearTimeout(pressTimerExp);
        pressTimerExp = null;
        longPressStarted = false;
        if (isDraggingAndRecording) {
          isDraggingAndRecording = false;
          isDragging = false;
          errorSentenceEl.classList.remove("dragging");
          
          // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if (stopRecordingTimer) {
            clearTimeout(stopRecordingTimer);
          }
          
          // è®¾ç½®3ç§’ååœæ­¢å½•éŸ³
          stopRecordingTimer = setTimeout(() => {
            if (recognition) {
              try {
                recognition.stop();
              } catch (ex) {
                console.error("[Transcription] error stopping:", ex);
              }
            }
          }, 3000);
        }
      });
    }

    /*******************************************************
     * Transcription: çœŸæ­£æ‰§è¡Œé•¿æŒ‰æ‹–æ‹½é€‰è¯
     *******************************************************/
    function handleExpLongPress() {
      console.log('[Transcription] handleExpLongPress started');
      
      const element = document.getElementById("error-sentence");
      if (!element) {
        console.warn('[Transcription] Error: element not found');
        return;
      }

      isDragging = true;
      element.classList.add("dragging");
      showCursorAtPosition();
      
      // å¼€å§‹å½•éŸ³ï¼Œä½†è®¾ç½®ä¸ºä¸è‡ªåŠ¨å¤„ç†ç»“æœ
      startRecording(true);

      const handleMouseMove = (e) => {
        if (!isDragging) return;
        e.preventDefault();

        if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(e.clientX, e.clientY);
          if (range && range.startContainer === element.firstChild) {
            localTapIndex = range.startOffset;
          }
        } else {
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          const paddingLeft = parseFloat(style.paddingLeft);
          const moveX = e.clientX - rect.left - paddingLeft;
          const fontSize = parseFloat(style.fontSize);
          const averageCharWidth = fontSize * 0.6;
          localTapIndex = Math.round(moveX / averageCharWidth);
        }
        const text = element.innerText;
        localTapIndex = Math.max(0, Math.min(text.length, localTapIndex));

        // åŠ¨æ€æ›´æ–°é€‰ä¸­çš„å¥å­
        const sentenceInfo = getCurrentSentenceForTranscription(text, localTapIndex);
        console.log("Mouse move - Position info:", {
          localTapIndex: localTapIndex,
          startIndex: sentenceInfo.startIndex,
          relativePosition: sentenceInfo.relativePosition,
          sentence: sentenceInfo.sentence
        });
        
        errorText.innerText = sentenceInfo.sentence;
        originalSentence = sentenceInfo.sentence;
        originalErrorSpan.innerText = sentenceInfo.sentence;
        selectedSentence = sentenceInfo.sentence;
        
        // æ›´æ–°å½“å‰å¥å­ä¿¡æ¯
        currentSentenceInfo = sentenceInfo;
        // æ›´æ–°ç›¸å¯¹ä½ç½®ï¼Œç”¨äºfinalizeTapSay
        tapStartIndex = sentenceInfo.relativePosition;
        
        showCursorAtPosition();
      };

      const handleTouchMove = (e) => {
        if (!isDragging) return;
        e.preventDefault();

        const touch = e.touches[0];
        if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(touch.clientX, touch.clientY);
          if (range && range.startContainer === element.firstChild) {
            localTapIndex = range.startOffset;
          }
        } else {
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          const paddingLeft = parseFloat(style.paddingLeft);
          const moveX = touch.clientX - rect.left - paddingLeft;
          const fontSize = parseFloat(style.fontSize);
          const averageCharWidth = fontSize * 0.6;
          localTapIndex = Math.round(moveX / averageCharWidth);
        }
        const text = element.innerText;
        localTapIndex = Math.max(0, Math.min(text.length, localTapIndex));

        // åŠ¨æ€æ›´æ–°é€‰ä¸­çš„å¥å­
        const sentenceInfo = getCurrentSentenceForTranscription(text, localTapIndex);
        console.log("Touch move - Position info:", {
          localTapIndex: localTapIndex,
          startIndex: sentenceInfo.startIndex,
          relativePosition: sentenceInfo.relativePosition,
          sentence: sentenceInfo.sentence
        });
        
        errorText.innerText = sentenceInfo.sentence;
        originalSentence = sentenceInfo.sentence;
        originalErrorSpan.innerText = sentenceInfo.sentence;
        selectedSentence = sentenceInfo.sentence;
        
        // æ›´æ–°å½“å‰å¥å­ä¿¡æ¯
        currentSentenceInfo = sentenceInfo;
        // æ›´æ–°ç›¸å¯¹ä½ç½®ï¼Œç”¨äºfinalizeTapSay
        tapStartIndex = sentenceInfo.relativePosition;

        showCursorAtPosition();
      };

      const endDrag = (e) => {
        if (e && e.type === 'touchend') e.preventDefault();
        isDragging = false;
        element.classList.remove("dragging");
        
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", endDrag);
        element.removeEventListener("touchmove", handleTouchMove);
        document.removeEventListener("touchend", endDrag);

        // å¦‚æœå¤„äºå½•éŸ³çŠ¶æ€ï¼Œç°åœ¨å‘é€è¯­éŸ³å†…å®¹
        if (isDraggingAndRecording) {
          isDraggingAndRecording = false;
        if (recognition) {
            console.log("Speech recognition ended and processing results");
            recognition.stop();
            
            // æ·»åŠ ç®€çŸ­å»¶è¿Ÿç¡®ä¿è¯†åˆ«ç»“æœè¢«å¤„ç†
        setTimeout(() => {
              if (voiceInputSpan.innerText && voiceInputSpan.innerText.trim()) {
                // ä½¿ç”¨æœ€ç»ˆçš„å¥å­ä¿¡æ¯å’Œç›¸å¯¹ä½ç½®
                if (currentSentenceInfo) {
                  const relativePosition = currentSentenceInfo.relativePosition;
                  console.log("End drag - Final position:", {
                    currentSentenceInfo: currentSentenceInfo,
                    relativePosition: relativePosition
                  });
                  
                  // ä½¿ç”¨æœ€ç»ˆå½•éŸ³ç»“æœå¤„ç†çº æ­£ï¼Œä¼ é€’ç›¸å¯¹ä½ç½®
                  handleRecognitionResult(voiceInputSpan.innerText, relativePosition);
                }
              }
            }, 300);
          }
        }
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", endDrag);
      element.addEventListener("touchmove", handleTouchMove, { passive: false });
      document.addEventListener("touchend", endDrag, { passive: false });
    }

    // ä¿®æ”¹getCurrentSentenceForTranscriptionå‡½æ•°ï¼Œè¿”å›æ›´å¤šä¿¡æ¯
    function getCurrentSentenceForTranscription(text, position) {
      const sentenceSeparators = /[.!?]/;
      let startPos = 0;
      let foundSeparator = false;
      
      // å‘å‰æœç´¢å¥å­åˆ†éš”ç¬¦
      for (let i = position - 1; i >= 0; i--) {
        if (sentenceSeparators.test(text[i]) &&
          (i + 1 >= text.length || text[i + 1] === ' ' || text[i + 1] === '\n')) {
          startPos = i + 1;
          while (startPos < text.length && (text[startPos] === ' ' || text[startPos] === '\n')) {
            startPos++;
          }
          foundSeparator = true;
          break;
        }
      }
      
      // å¦‚æœæ‰¾ä¸åˆ°åˆ†éš”ç¬¦ï¼Œåˆ™ä»æ–‡æœ¬å¼€å§‹
      if (!foundSeparator) {
        startPos = 0;
        // è·³è¿‡å¼€å¤´çš„ç©ºç™½
        while (startPos < text.length && (text[startPos] === ' ' || text[startPos] === '\n')) {
          startPos++;
        }
      }
      
      let endPos = text.length;
      let foundEndSeparator = false;
      
      // å‘åæœç´¢å¥å­åˆ†éš”ç¬¦
      for (let i = position; i < text.length; i++) {
        if (sentenceSeparators.test(text[i])) {
          endPos = i + 1;
          foundEndSeparator = true;
          break;
        }
      }
      
      // å¦‚æœæ‰¾ä¸åˆ°ç»“æŸåˆ†éš”ç¬¦ï¼Œåˆ™åˆ°æ–‡æœ¬ç»“æŸ
      if (!foundEndSeparator) {
        endPos = text.length;
      }
      
      const sentence = text.substring(startPos, endPos).trim();
      selectedSentence = sentence;
      
      // ç¡®ä¿ç›¸å¯¹ä½ç½®è®¡ç®—æ­£ç¡®
      const relativePos = position - startPos;
      
      console.log("Sentence detection:", {
        fullText: text,
        position: position,
        startPos: startPos,
        endPos: endPos,
        relativePosition: relativePos,
        sentence: sentence
      });
      
      // è¿”å›åŒ…å«å¥å­ä¿¡æ¯çš„å¯¹è±¡
      return {
        sentence: sentence,
        startIndex: startPos,
        endIndex: endPos,
        relativePosition: relativePos
      };
    }

    /*******************************************************
     * Transcription: åœ¨é•¿æŒ‰æ—¶å‡ºç°çš„å…‰æ ‡
     *******************************************************/
    function showCursorAtPosition() {
      removeCursor();
      const element = document.getElementById("error-sentence");
      if (!element) return;

      const text = element.textContent;
      const textNode = element.firstChild;
      if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return;

      try {
        const style = window.getComputedStyle(element);
        const range = document.createRange();
        range.setStart(textNode, localTapIndex);
        range.collapse(true);

        const rangeRect = range.getBoundingClientRect();
        
        cursorElement = document.createElement("span");
        cursorElement.className = "cursor-indicator";
        cursorElement.style.position = "absolute";

        cursorElement.style.left = (rangeRect.left + window.scrollX) + "px";
        cursorElement.style.top = (rangeRect.top + window.scrollY) + "px";
        cursorElement.style.height = rangeRect.height + "px";

        document.body.appendChild(cursorElement);
        cursorElement.dataset.index = localTapIndex.toString();
        cursorElement.dataset.elementId = "error-sentence";

        if (!isRecording && !isDragging) {
          cursorTimeout = setTimeout(() => { removeCursor(); }, 6000);
        }
        touchIndexSpan.innerText = String(localTapIndex);
      } catch (e) {
        console.error("[Transcription] Error creating cursor:", e);
      }
    }

    function showLongPressFeedback(x, y) {
      // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é•¿æŒ‰åé¦ˆåŠ¨ç”»
      console.log("Long-press at:", x, y);
    }

    /*******************************************************
     * Transcription: æ£€æŸ¥å½“å‰æ˜¯å¦å®Œæˆä¿®æ­£
     *******************************************************/
    function checkCompletion() {
      const targetSentence = document.getElementById("target-sentence");
      const errorSentence = document.getElementById("error-sentence");
      const skipBtn = document.getElementById("skip-sentence-button");
      if (!targetSentence || !errorSentence) return;

      if (errorSentence.innerText.trim() === targetSentence.textContent.trim()) {
        errorSentence.style.background = "#e6ffed";
        errorSentence.style.borderColor = "#34d058";
        setTimeout(() => {
          errorSentence.style.background = "";
          errorSentence.style.borderColor = "";
        }, 2000);

        if (skipBtn && skipBtn.parentNode) {
          const parentElement = skipBtn.parentNode;
          let newElement;
          if (currentPairIndex === sentencePairs.length - 1) {
            newElement = document.createElement("div");
            newElement.id = "skip-sentence-button";
            newElement.textContent = "That's the last one";
            newElement.style.flex = "1";
            newElement.style.padding = "14px";
            newElement.style.fontSize = "16px";
            newElement.style.border = "none";
            newElement.style.borderRadius = "6px";
            newElement.style.background = "#6c757d";
            newElement.style.color = "#fff";
            newElement.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
            newElement.style.cursor = "default";
            newElement.style.opacity = "0.7";
            newElement.style.textAlign = "center";
            newElement.style.userSelect = "none";
            newElement.style.pointerEvents = "none";
          } else {
            newElement = document.createElement("button");
            newElement.id = "skip-sentence-button";
            newElement.textContent = "Next Sentence";
            newElement.style.flex = "1";
            newElement.style.padding = "14px";
            newElement.style.fontSize = "16px";
            newElement.style.border = "none";
            newElement.style.borderRadius = "6px";
            newElement.style.background = "#007bff";
            newElement.style.color = "#fff";
            newElement.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
            newElement.style.cursor = "pointer";

            newElement.addEventListener("click", function nextHandler() {
              currentPairIndex++;
              updateSentencePair(currentPairIndex);
            });
          }
          parentElement.replaceChild(newElement, skipBtn);
        }
      }
    }

    /*******************************************************
     * Transcription: æ›´æ–°å¥å­å¯¹
     *******************************************************/
    function updateSentencePair(index) {
      const targetSentence = document.getElementById("target-sentence");
      const errorSentenceEl = document.getElementById("error-sentence");
      const indexSpan = document.getElementById("sentence-index");
      const prev = document.getElementById("prev-sentence");
      const next = document.getElementById("next-sentence");

      const oldTip = document.querySelector('.tip-box');
      if (oldTip) oldTip.remove();

      const container = document.getElementById("experience-mode");
      container.insertBefore(addTipBox(sentencePairs[index].tip), container.firstChild);

      if (targetSentence) targetSentence.textContent = sentencePairs[index].target;
      if (errorSentenceEl) {
        errorSentenceEl.textContent = sentencePairs[index].error;
        originalSentence = sentencePairs[index].error;
      }

      if (indexSpan) indexSpan.textContent = (index + 1) + "/" + sentencePairs.length;
      if (prev) prev.style.visibility = (index === 0) ? "hidden" : "visible";
      if (next) next.style.visibility = (index === sentencePairs.length - 1) ? "hidden" : "visible";

      const skipBtn = document.getElementById("skip-sentence-button");
      if (skipBtn && skipBtn.parentNode) {
        const parentElement = skipBtn.parentNode;
        const disabledBtn = document.createElement("div");
        disabledBtn.id = "skip-sentence-button";
        disabledBtn.textContent = "Next Sentence";
        disabledBtn.style.flex = "1";
        disabledBtn.style.padding = "14px";
        disabledBtn.style.fontSize = "16px";
        disabledBtn.style.border = "none";
        disabledBtn.style.borderRadius = "6px";
        disabledBtn.style.background = "#6c757d";
        disabledBtn.style.color = "#fff";
        disabledBtn.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
        disabledBtn.style.cursor = "default";
        disabledBtn.style.opacity = "0.7";
        disabledBtn.style.textAlign = "center";
        disabledBtn.style.userSelect = "none";
        disabledBtn.style.pointerEvents = "none";
        parentElement.replaceChild(disabledBtn, skipBtn);
      }
    }

    function addTipBox(tip) {
      const tipBox = document.createElement('div');
      tipBox.className = 'tip-box';
      tipBox.innerHTML = `
        <div class="tip-content">
          ${tip}
        </div>
      `;
      return tipBox;
    }

    /*******************************************************
     * è¦†ç›–: applyFirstSuggestionAndShowBox (Transcription)
     *******************************************************/
    const originalApply = applyFirstSuggestionAndShowBox;
    applyFirstSuggestionAndShowBox = function(corrections, isExperienceMode) {
      if (!corrections.length) return;
      
      if (isExperienceMode) {
        // ==========ã€åŸå§‹çš„ Transcription é€»è¾‘ã€‘==========
        if (!document.getElementById("error-sentence")) return;
        
        let candidateObj = corrections[0];
        let candidate = candidateObj.corrected_text.trimEnd();
        let diffRanges = candidateObj.diff_ranges;
        
        const errorSentenceEl = document.getElementById("error-sentence");
        let entireText = errorSentenceEl.innerText;
        
        // å°†åŸå…ˆé€‰ä¸­çš„å¥å­æ›¿æ¢ä¸º candidate
        let updatedText = replaceFirstOccurrence(entireText, selectedSentence, candidate);
        errorSentenceEl.innerText = updatedText;
        selectedSentence = candidate;

        // å¦‚æœæœ‰ diffRanges å°±åŠ ä¸‹åˆ’çº¿
        if (diffRanges && diffRanges.length > 0) {
          let newSentenceIndex = updatedText.indexOf(candidate);
          if (newSentenceIndex >= 0) {
            let newHtml = updatedText.substring(0, newSentenceIndex);
            newHtml += underlineDiffRanges(candidate, diffRanges);
            newHtml += updatedText.substring(newSentenceIndex + candidate.length);
            errorSentenceEl.innerHTML = newHtml;
            
            setTimeout(() => {
              errorSentenceEl.innerText = errorSentenceEl.innerText;
            }, 2000);
          }
        }

        // å¦‚æœæœ‰å¤šä¸ªä¿®æ­£å»ºè®®ï¼Œåˆ™å±•ç¤ºå»ºè®®åˆ—è¡¨
        if (corrections.length > 1) {
          let rect = errorSentenceEl.getBoundingClientRect();
          suggestionsBox = createSuggestionBox(rect, corrections, true);
          if (suggestionsBox) {
            document.body.appendChild(suggestionsBox);
            clearTimeout(suggestionsTimer);
            suggestionsTimer = setTimeout(removeSuggestionsBox, 3000);
          }
        }
        checkCompletion();
      } else {
        // å¦‚æœä¸æ˜¯Experienceæ¨¡å¼ï¼Œå°±è°ƒç”¨åé¢ free-input çš„é€»è¾‘
        originalApply(corrections, isExperienceMode);
      }
    };

    /*******************************************************
     * Transcription: åˆ›å»ºä¸€ä¸ªå»ºè®®box
     *******************************************************/
    function createSuggestionBox(rect, corrections, isExpMode) {
      let box = document.createElement("div");
      box.className = "suggestions-box-floating";
      
      if (isExpMode) {
        // Transcriptionæ¨¡å¼çš„å®šä½é€»è¾‘ä¿æŒä¸å˜
        const errorSentenceEl = document.getElementById("error-sentence");
        if (errorSentenceEl) {
          const text = errorSentenceEl.innerText;
          const firstSuggestion = corrections[0].corrected_text.trimEnd();
          const range = document.createRange();
          const textNode = errorSentenceEl.firstChild;
          
          if (textNode) {
            const startIndex = text.indexOf(firstSuggestion);
            if (startIndex !== -1) {
              try {
                range.setStart(textNode, startIndex);
                range.setEnd(textNode, startIndex + 1);
                const selectedRect = range.getBoundingClientRect();
                const boxLeft = selectedRect.left + window.scrollX;
                const boxTop = selectedRect.bottom + window.scrollY + 5;

                box.style.left = boxLeft + "px";
                box.style.top = boxTop + "px";
                box.style.minWidth = selectedRect.width + "px";
                box.style.width = "auto";
                box.style.maxWidth = "500px";
              } catch (e) {
                console.error('[SuggestionBox] Error setting range:', e);
              }
            }
          }
        }
      } else {
        // è‡ªç”±è¾“å…¥æ¨¡å¼çš„å®šä½é€»è¾‘
        const simpleEditor = document.getElementById('simple-editor');
        if (simpleEditor && originalSentence) {
          const text = simpleEditor.textContent;
          const sentenceStart = text.indexOf(originalSentence);
          
          if (sentenceStart !== -1) {
            try {
              // åˆ›å»ºä¸€ä¸ªèŒƒå›´æ¥è·å–é€‰ä¸­å¥å­çš„ä½ç½®
              const range = document.createRange();
              const textNode = simpleEditor.firstChild;
              range.setStart(textNode, sentenceStart);
              range.setEnd(textNode, sentenceStart + originalSentence.length);
              
              // è·å–é€‰ä¸­æ–‡æœ¬çš„ä½ç½®ä¿¡æ¯
              const sentenceRect = range.getBoundingClientRect();
              
              // è®¾ç½®å»ºè®®æ¡†çš„æ ·å¼å’Œä½ç½®
              box.style.position = 'absolute';
              box.style.top = (sentenceRect.bottom + window.scrollY + 5) + 'px';  // åœ¨å¥å­ä¸‹æ–¹5pxå¤„
              box.style.left = (sentenceRect.left + window.scrollX) + 'px';
              box.style.width = 'auto';
              box.style.maxWidth = simpleEditor.offsetWidth - 40 + 'px'; // ç•™å‡ºä¸€äº›è¾¹è·
              box.style.zIndex = '1000';
              
              // ç›´æ¥å°†å»ºè®®æ¡†æ·»åŠ åˆ°æ–‡æ¡£ä¸­
              document.body.appendChild(box);
            } catch (e) {
              console.error('[SuggestionBox] Error calculating position:', e);
            }
          }
        }
      }

      for (let i = 1; i < corrections.length; i++) {
        let candidateObj = corrections[i];
        let candidate = candidateObj.corrected_text.trimEnd();
        let diffRanges = candidateObj.diff_ranges;

        let div = document.createElement("div");
        if (diffRanges && diffRanges.length > 0) {
          div.innerHTML = underlineDiffRanges(candidate, diffRanges);
        } else {
          div.innerText = candidate;
        }

        div.onclick = (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          if (isExpMode) {
            // Transcriptionæ¨¡å¼çš„ç‚¹å‡»å¤„ç†ä¿æŒä¸å˜
          const errorSentenceEl = document.getElementById("error-sentence");
          if (!errorSentenceEl) return;

          let entireText = errorSentenceEl.innerText;
          let updated = replaceFirstOccurrence(entireText, selectedSentence, candidate);
          errorSentenceEl.innerText = updated;
          selectedSentence = candidate;

          if (diffRanges && diffRanges.length > 0) {
            let newSentenceIndex = updated.indexOf(candidate);
            if (newSentenceIndex >= 0) {
              let newHtml = updated.substring(0, newSentenceIndex);
              newHtml += underlineDiffRanges(candidate, diffRanges);
              newHtml += updated.substring(newSentenceIndex + candidate.length);
              errorSentenceEl.innerHTML = newHtml;
              
              setTimeout(() => {
                errorSentenceEl.innerText = errorSentenceEl.innerText;
              }, 2000);
            }
          }
          checkCompletion();
          } else {
            // è‡ªç”±è¾“å…¥æ¨¡å¼çš„ç‚¹å‡»å¤„ç†
            window.replaceSentenceInSimpleEditor(originalSentence, candidate);
            originalSentence = candidate;
          }
          removeSuggestionsBox();
        };
        box.appendChild(div);
      }
      return box;
    }


    /*******************************************************
     * ============ C) è‡ªç”±è¾“å…¥æ¨¡å¼ ä»£ç  ============
     ***********************************************/

    /*******************************************************
     * Free Input: ä¸ºç®€å•æ–‡æœ¬åŒºæ·»åŠ äº‹ä»¶
     *******************************************************/
    function attachFreeInputListeners() {
      const editor = document.getElementById('simple-editor');
      if (!editor) return;
      
      // åˆå§‹åŒ–æ—¶å°†åˆå§‹å†…å®¹æ”¾å…¥æ’¤é”€æ ˆ
      simpleUndoStack = [editor.innerHTML];
      updateUndoButtonState();
      
      let pressTimer = null;
      let lastContent = editor.innerHTML;
      let touchStartX = 0;
      let touchStartY = 0;
      let isTouchMoved = false;
      let touchStartTime = 0;
      
      // PCç«¯é¼ æ ‡äº‹ä»¶å¤„ç†
      editor.addEventListener('mousedown', (e) => {
        if (activeMode !== MODE_INPUT) return;
        handlePressStart(e.clientX, e.clientY, false);
      });

      document.addEventListener('mouseup', () => {
        handlePressEnd();
      });

      // ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶å¤„ç†
      editor.addEventListener('touchstart', (e) => {
        if (activeMode !== MODE_INPUT) return;
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        touchStartTime = Date.now();
        isTouchMoved = false;
        
        // é•¿æŒ‰æ—¶å…ˆé˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé¿å…iOSçš„æ–‡æœ¬é€‰æ‹©åŠŸèƒ½
        if (e.touches.length === 1) {
          // ä¸æ˜¯æ»šåŠ¨æ“ä½œæ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸º
          const isScrollArea = (touch.clientY > (editor.offsetTop + editor.offsetHeight - 40));
          if (!isScrollArea) {
            e.preventDefault();
          }
        }
        
        handlePressStart(touch.clientX, touch.clientY, true);
      });

      editor.addEventListener('touchmove', (e) => {
        if (pressTimer) {
          const touch = e.touches[0];
          const moveX = Math.abs(touch.clientX - touchStartX);
          const moveY = Math.abs(touch.clientY - touchStartY);
          if (moveX > 10 || moveY > 10) {
            isTouchMoved = true;
            handlePressEnd();
          }
        }
      });

      editor.addEventListener('touchend', (e) => {
        if (!isTouchMoved) {
          const touchEndTime = Date.now();
          const touchDuration = touchEndTime - touchStartTime;
          
          if (touchDuration < 500) {
            // çŸ­æŒ‰ï¼Œå¤„ç†é€‰æ‹©
            const touch = e.changedTouches[0];
            const range = document.caretRangeFromPoint(touch.clientX, touch.clientY);
            if (range) {
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }
          handlePressEnd();
        }
      });

      // ç»Ÿä¸€çš„æŒ‰å‹å¼€å§‹å¤„ç†å‡½æ•°
      function handlePressStart(clientX, clientY, isTouch) {
        editor.focus();
        
        // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„åœæ­¢å½•éŸ³å®šæ—¶å™¨
        if (window.stopRecordingTimer) {
          clearTimeout(window.stopRecordingTimer);
          window.stopRecordingTimer = null;
        }
        
        pressTimer = setTimeout(() => {
          // æ¸…é™¤å¯èƒ½å·²æœ‰çš„é€‰æ‹©
          const selection = window.getSelection();
          selection.removeAllRanges();
          
          // æ ‡è®°ä¸ºæ‹–åŠ¨+å½•éŸ³çŠ¶æ€
          isDraggingAndRecording = true;
          
          // è·å–å½“å‰å¥å­
          const range = document.caretRangeFromPoint(clientX, clientY);
          if (range) {
            const sentenceInfo = getFreeInputSentence(editor.textContent, range.startOffset);
            errorText.innerText = sentenceInfo.sentence;
            originalSentence = sentenceInfo.sentence;
            originalErrorSpan.innerText = sentenceInfo.sentence;
            localTapIndex = range.startOffset;
            
            // å¼€å§‹å½•éŸ³ï¼Œä½†ä¸è‡ªåŠ¨å¤„ç†ç»“æœ
            startRecording(true);
          }
        }, isTouch ? 700 : 500); // è§¦æ‘¸è®¾å¤‡ä½¿ç”¨ç¨é•¿çš„é•¿æŒ‰æ—¶é—´
      }
      
      // ç»Ÿä¸€çš„æŒ‰å‹ç»“æŸå¤„ç†å‡½æ•°
      function handlePressEnd() {
        if (pressTimer) {
          clearTimeout(pressTimer);
          pressTimer = null;
        }
        
        // å¦‚æœå¤„äºæ‹–åŠ¨+å½•éŸ³çŠ¶æ€ï¼Œåªéœ€æ ‡è®°ä¸ºç»“æŸï¼Œä½†ä¸ç«‹å³åœæ­¢å½•éŸ³
        if (isDraggingAndRecording) {
          isDraggingAndRecording = false;
          
          // æ¸…é™¤ä¹‹å‰å¯èƒ½å­˜åœ¨çš„åœæ­¢å½•éŸ³å®šæ—¶å™¨
          if (window.stopRecordingTimer) {
            clearTimeout(window.stopRecordingTimer);
          }
          
          // è®¾ç½®3ç§’ååœæ­¢å½•éŸ³
          window.stopRecordingTimer = setTimeout(() => {
            if (recognition) {
              console.log("Free input: 3ç§’åè‡ªåŠ¨åœæ­¢å½•éŸ³");
              try {
                recognition.stop();
                // onendäº‹ä»¶å¤„ç†ç¨‹åºä¼šè°ƒç”¨finalizeTapSay
              } catch (ex) {
                console.error("Error stopping recognition:", ex);
              }
            }
          }, 3000);
        }
      }
      
      // ç›‘å¬inputå˜åŒ–æ¨å…¥undoæ ˆ
      editor.addEventListener('input', function() {
        const currentContent = this.innerHTML;
        // åªæœ‰å½“å†…å®¹çœŸçš„æ”¹å˜æ—¶æ‰æ·»åŠ åˆ°æ’¤é”€æ ˆ
        if (currentContent !== lastContent) {
          simpleUndoStack.push(currentContent);
        if (simpleUndoStack.length > 20) {
          simpleUndoStack.shift();
          }
          lastContent = currentContent;
          updateUndoButtonState();
        }
      });
      
      // æ–‡ä»¶æ‹–æ‹½
      editor.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.style.background = "#fafafa";
      });
      
      editor.addEventListener('dragleave', function() {
        this.style.background = "#fff";
      });
      
      editor.addEventListener('drop', function(e) {
        e.preventDefault();
        this.style.background = "#fff";

        const files = e.dataTransfer.files;
        if (files.length > 0) {
          const file = files[0];
          const fname = file.name.toLowerCase();
          if (fname.endsWith(".txt") || fname.endsWith(".doc")) {
            let reader = new FileReader();
            reader.onload = (evt) => {
              this.textContent = evt.target.result;
              simpleUndoStack.push(this.innerHTML);
              lastContent = this.innerHTML;
              updateUndoButtonState();
              logEvent("File loaded: " + file.name);
            };
            reader.readAsText(file, "UTF-8");
          } else {
            console.warn("Only .txt or .doc files are supported");
          }
        }
      });

      // æ·»åŠ è‡ªç”±è¾“å…¥æ¨¡å¼çš„ç§»åŠ¨ç›‘å¬å™¨
      editor.addEventListener('mousemove', (e) => {
        if (isDraggingAndRecording) {
          const range = document.caretRangeFromPoint(e.clientX, e.clientY);
          if (range) {
            const sentenceInfo = getFreeInputSentence(editor.textContent, range.startOffset);
            errorText.innerText = sentenceInfo.sentence;
            originalSentence = sentenceInfo.sentence;
            originalErrorSpan.innerText = sentenceInfo.sentence;
          }
        }
      });

      editor.addEventListener('touchmove', (e) => {
        if (isDraggingAndRecording) {
          const touch = e.touches[0];
          const range = document.caretRangeFromPoint(touch.clientX, touch.clientY);
          if (range) {
            const sentenceInfo = getFreeInputSentence(editor.textContent, range.startOffset);
            errorText.innerText = sentenceInfo.sentence;
            originalSentence = sentenceInfo.sentence;
            originalErrorSpan.innerText = sentenceInfo.sentence;
          }
        } else if (pressTimer) {
          const touch = e.touches[0];
          const moveX = Math.abs(touch.clientX - touchStartX);
          const moveY = Math.abs(touch.clientY - touchStartY);
          if (moveX > 10 || moveY > 10) {
            isTouchMoved = true;
            handlePressEnd();
          }
        }
      });
    }

    // ä¸“é—¨è·å–å¥å­
    function getFreeInputSentence(text, position) {
      const sentenceSeparators = /[.!?]/;
      let startPos = 0;
      for (let i = position - 1; i >= 0; i--) {
        if (sentenceSeparators.test(text[i]) &&
          (i + 1 >= text.length || text[i + 1] === ' ' || text[i + 1] === '\n')) {
          startPos = i + 1;
          while (startPos < text.length && (text[startPos] === ' ' || text[startPos] === '\n')) {
            startPos++;
          }
          break;
        }
      }
      
      let endPos = text.length;
      for (let i = position; i < text.length; i++) {
        if (sentenceSeparators.test(text[i])) {
          endPos = i + 1;
          break;
        }
      }
      return { sentence: text.substring(startPos, endPos).trim(), startPos: startPos, endPos: endPos };
    }

    // Free-inputä¸“ç”¨çš„undoæ ˆ
    let simpleUndoStack = [''];
    const simpleUndoButton = document.getElementById('simple-undo-button');

    // æ›´æ–°æŒ‰é’®çŠ¶æ€çš„å‡½æ•°
    function updateUndoButtonState() {
      const simpleUndoButton = document.getElementById('simple-undo-button');
      if (simpleUndoButton) {
        if (simpleUndoStack.length <= 1) {
          simpleUndoButton.disabled = true;
          simpleUndoButton.style.background = '#6c757d';
          simpleUndoButton.style.cursor = 'not-allowed';
        } else {
          simpleUndoButton.disabled = false;
          simpleUndoButton.style.background = '#28a745';
          simpleUndoButton.style.cursor = 'pointer';
        }
      }
    }

    if (simpleUndoButton) {
      // åˆå§‹çŠ¶æ€
      updateUndoButtonState();
      
      simpleUndoButton.addEventListener('click', function() {
        const simpleEditor = document.getElementById('simple-editor');
        if (simpleEditor && simpleUndoStack.length > 1) {
          // ç§»é™¤å½“å‰çŠ¶æ€
          simpleUndoStack.pop();
          // æ¢å¤åˆ°ä¸Šä¸€ä¸ªçŠ¶æ€
          const previousContent = simpleUndoStack[simpleUndoStack.length - 1];
          simpleEditor.innerHTML = previousContent;
          
          // å°†å…‰æ ‡ç§»åˆ°æœ«å°¾
          const range = document.createRange();
          const selection = window.getSelection();
          range.selectNodeContents(simpleEditor);
          range.collapse(false);
          selection.removeAllRanges();
          selection.addRange(range);
          
          simpleEditor.focus();
          updateUndoButtonState();
        }
      });
    }

    // ç”¨æ¥æ›¿æ¢å¥å­(è‡ªç”±æ¨¡å¼)
    window.replaceSentenceInSimpleEditor = function(originalText, newText) {
      const simpleEditor = document.getElementById('simple-editor');
      if (!simpleEditor) return false;
      
      const currentContent = simpleEditor.innerHTML;
      const updatedContent = currentContent.replace(originalText, newText);
      
      if (currentContent !== updatedContent) {
        simpleUndoStack.push(updatedContent);
        simpleEditor.innerHTML = updatedContent;
        updateUndoButtonState();
      return true;
      }
      return false;
    };

    /*******************************************************
     * è¦†ç›–: applyFirstSuggestionAndShowBox (Free Input)
     *******************************************************/
    const originalApplyGlobal = applyFirstSuggestionAndShowBox;
    applyFirstSuggestionAndShowBox = function(corrections, isExperienceMode) {
      if (!corrections.length) return;
      
      if (isExperienceMode) {
        // å¦‚æœæ˜¯Transcriptionæ¨¡å¼ï¼Œè°ƒç”¨ä¹‹å‰è¦†ç›–çš„ç‰ˆæœ¬
        originalApplyGlobal(corrections, isExperienceMode);
      } else {
        // ==========ã€Free Inputæ¨¡å¼é€»è¾‘ã€‘==========
        const simpleEditor = document.getElementById('simple-editor');
        if (!simpleEditor) return;
        
        let candidateObj = corrections[0];
        let candidate = candidateObj.corrected_text.trimEnd();
        let diffRanges = candidateObj.diff_ranges;
        
        if (window.replaceSentenceInSimpleEditor(originalSentence, candidate)) {
          originalSentence = candidate;
          simpleEditor.focus();

          if (corrections.length > 1) {
            suggestionsBox = createSuggestionBox(null, corrections, false);
            if (suggestionsBox) {
              document.body.appendChild(suggestionsBox);
              clearTimeout(suggestionsTimer);
              suggestionsTimer = setTimeout(removeSuggestionsBox, 3000);
            }
          }
        }
      }
    };

    /*******************************************************
     * Transcription: åˆ›å»ºä¸€ä¸ªå»ºè®®box
     *******************************************************/
    function createSuggestionBox(rect, corrections, isExpMode) {
      let box = document.createElement("div");
      box.className = "suggestions-box-floating";
      
      if (isExpMode) {
        // Transcriptionæ¨¡å¼çš„å®šä½é€»è¾‘ä¿æŒä¸å˜
        const errorSentenceEl = document.getElementById("error-sentence");
        if (errorSentenceEl) {
          const text = errorSentenceEl.innerText;
          const firstSuggestion = corrections[0].corrected_text.trimEnd();
          const range = document.createRange();
          const textNode = errorSentenceEl.firstChild;
          
          if (textNode) {
            const startIndex = text.indexOf(firstSuggestion);
            if (startIndex !== -1) {
              try {
                range.setStart(textNode, startIndex);
                range.setEnd(textNode, startIndex + 1);
                const selectedRect = range.getBoundingClientRect();
                const boxLeft = selectedRect.left + window.scrollX;
                const boxTop = selectedRect.bottom + window.scrollY + 5;

                box.style.left = boxLeft + "px";
                box.style.top = boxTop + "px";
                box.style.minWidth = selectedRect.width + "px";
                box.style.width = "auto";
                box.style.maxWidth = "500px";
              } catch (e) {
                console.error('[SuggestionBox] Error setting range:', e);
              }
            }
          }
        }
      } else {
        // è‡ªç”±è¾“å…¥æ¨¡å¼çš„å®šä½é€»è¾‘
        const simpleEditor = document.getElementById('simple-editor');
        if (simpleEditor && originalSentence) {
          const text = simpleEditor.textContent;
          const sentenceStart = text.indexOf(originalSentence);
          
          if (sentenceStart !== -1) {
            try {
              // åˆ›å»ºä¸€ä¸ªèŒƒå›´æ¥è·å–é€‰ä¸­å¥å­çš„ä½ç½®
              const range = document.createRange();
              const textNode = simpleEditor.firstChild;
              range.setStart(textNode, sentenceStart);
              range.setEnd(textNode, sentenceStart + originalSentence.length);
              
              // è·å–é€‰ä¸­æ–‡æœ¬çš„ä½ç½®ä¿¡æ¯
              const sentenceRect = range.getBoundingClientRect();
              
              // è®¾ç½®å»ºè®®æ¡†çš„æ ·å¼å’Œä½ç½®
              box.style.position = 'absolute';
              box.style.top = (sentenceRect.bottom + window.scrollY + 5) + 'px';  // åœ¨å¥å­ä¸‹æ–¹5pxå¤„
              box.style.left = (sentenceRect.left + window.scrollX) + 'px';
              box.style.width = 'auto';
              box.style.maxWidth = simpleEditor.offsetWidth - 40 + 'px'; // ç•™å‡ºä¸€äº›è¾¹è·
              box.style.zIndex = '1000';
              
              // ç›´æ¥å°†å»ºè®®æ¡†æ·»åŠ åˆ°æ–‡æ¡£ä¸­
              document.body.appendChild(box);
            } catch (e) {
              console.error('[SuggestionBox] Error calculating position:', e);
            }
          }
        }
      }

      for (let i = 1; i < corrections.length; i++) {
        let candidateObj = corrections[i];
        let candidate = candidateObj.corrected_text.trimEnd();
        let diffRanges = candidateObj.diff_ranges;

        let div = document.createElement("div");
        if (diffRanges && diffRanges.length > 0) {
          div.innerHTML = underlineDiffRanges(candidate, diffRanges);
        } else {
          div.innerText = candidate;
        }

        div.onclick = (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          if (isExpMode) {
            // Transcriptionæ¨¡å¼çš„ç‚¹å‡»å¤„ç†ä¿æŒä¸å˜
            const errorSentenceEl = document.getElementById("error-sentence");
            if (!errorSentenceEl) return;

            let entireText = errorSentenceEl.innerText;
            let updated = replaceFirstOccurrence(entireText, selectedSentence, candidate);
            errorSentenceEl.innerText = updated;
            selectedSentence = candidate;

            if (diffRanges && diffRanges.length > 0) {
              let newSentenceIndex = updated.indexOf(candidate);
              if (newSentenceIndex >= 0) {
                let newHtml = updated.substring(0, newSentenceIndex);
                newHtml += underlineDiffRanges(candidate, diffRanges);
                newHtml += updated.substring(newSentenceIndex + candidate.length);
                errorSentenceEl.innerHTML = newHtml;
                
                setTimeout(() => {
                  errorSentenceEl.innerText = errorSentenceEl.innerText;
                }, 2000);
              }
            }
            checkCompletion();
          } else {
            // è‡ªç”±è¾“å…¥æ¨¡å¼çš„ç‚¹å‡»å¤„ç†
            window.replaceSentenceInSimpleEditor(originalSentence, candidate);
            originalSentence = candidate;
          }
          removeSuggestionsBox();
        };
        box.appendChild(div);
      }
      return box;
    }


    /*******************************************************
     * ============ D) window.onload & ä¸»å…¥å£ ============
     *******************************************************/
    window.onload = async function() {
      // å°è¯•åŠ è½½header/footer
      try {
        const headerRes = await fetch("header.html");
        const headerHtml = await headerRes.text();
        document.getElementById("header-container").innerHTML = headerHtml;

        const footerRes = await fetch("footer.html");
        const footerHtml = await footerRes.text();
        document.getElementById("footer-container").innerHTML = footerHtml;
      } catch(e) {
        console.warn("Failed to load header/footer:", e);
      }

      // é»˜è®¤éšè— monitoring å’Œ event log
      monitoringCard.style.display = "none";
      eventLogCard.style.display = "none";

      // æ£€æŸ¥éº¦å…‹é£æƒé™
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({audio: true})
        .catch(err => {
          console.warn("Mic permission error:", err);
        });
      }

      // åˆå§‹åŒ–æ¨¡å¼
      modeExperienceContainer.style.display = "block";
      modeInputContainer.style.display = "none";
      modeExperienceBtn.classList.add("active");
      modeInputBtn.classList.remove("active");
      activeMode = MODE_EXPERIENCE;

      // åˆå§‹åŒ–Transcriptionæ¨¡å¼
      initializeExperienceMode();

      // ä¸ºFree Input modeæ·»åŠ æç¤ºæ¡†
      const inputModeContainer = document.getElementById("input-mode");
      if (inputModeContainer) {
        inputModeContainer.insertBefore(
          addTipBox("Tap on the place you want to edit, till the mic icon is green, then speak correction. "),
          inputModeContainer.firstChild
        );
      }

      // ç»‘å®šFree Inputç›‘å¬
      attachFreeInputListeners();

      // å–æ¶ˆé€‰ä¸­æ–‡æœ¬(Transcriptionæ¨¡å¼æ—¶)
      document.addEventListener('mouseup', () => {
        if (activeMode === MODE_EXPERIENCE && !isDragging) {
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const errorSentenceEl = document.getElementById("error-sentence");
            if (errorSentenceEl && !errorSentenceEl.classList.contains('dragging')) {
              selection.removeAllRanges();
            }
          }
        }
      });
      document.addEventListener('selectionchange', () => {
        if (activeMode === MODE_EXPERIENCE && !isDragging) {
          const errorSentenceEl = document.getElementById("error-sentence");
          if (errorSentenceEl && !errorSentenceEl.classList.contains('dragging')) {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
              const range = selection.getRangeAt(0);
              if (errorSentenceEl.contains(range.commonAncestorContainer)) {
                selection.removeAllRanges();
              }
            }
          }
        }
      });

      // ç›‘å¬æ¨¡å¼åˆ‡æ¢
      modeExperienceBtn.addEventListener("click", function() {
        if (!this.classList.contains("active")) {
          this.classList.add("active");
          modeInputBtn.classList.remove("active");
          modeExperienceContainer.style.display = "block";
          modeInputContainer.style.display = "none";
          activeMode = MODE_EXPERIENCE;
        }
      });
      modeInputBtn.addEventListener("click", function() {
        if (!this.classList.contains("active")) {
          this.classList.add("active");
          modeExperienceBtn.classList.remove("active");
          modeExperienceContainer.style.display = "none";
          modeInputContainer.style.display = "block";
          activeMode = MODE_INPUT;
        }
      });

      // æ‰“Log
      logEvent("Application initialized - Monitoring and logs are hidden by default");


      /*******************************************************
       * æµ®åŠ¨èœå•ç›¸å…³é€»è¾‘
       *******************************************************/
      const menuButton = document.getElementById('float-menu-button');
      const menu = document.getElementById('float-menu');
      menu.innerHTML = `
        <button id="float-monitoring">
          Show Monitoring
        </button>
        <button id="float-log">
          Show Event Log
        </button>
      `;

      let menuVisible = false;
      menuButton.innerHTML = `
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path fill="white" d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
      `;

      menuButton.addEventListener('click', (e) => {
        e.stopPropagation();
        menuVisible = !menuVisible;
        menu.style.display = menuVisible ? 'flex' : 'none';
      });
      document.addEventListener('click', (e) => {
        if (!menu.contains(e.target) && !menuButton.contains(e.target)) {
          menuVisible = false;
          menu.style.display = 'none';
        }
      });

      const floatMonitoringBtn = document.getElementById('float-monitoring');
      const floatLogBtn = document.getElementById('float-log');
      const floatImeBtn = document.getElementById('float-ime');

      if (floatMonitoringBtn) {
        floatMonitoringBtn.addEventListener('click', () => {
          const isHidden = (monitoringCard.style.display === 'none');
          monitoringCard.style.display = isHidden ? 'block' : 'none';
          floatMonitoringBtn.textContent = isHidden ? 'Hide Monitoring' : 'Show Monitoring';
        });
      }
      if (floatLogBtn) {
        floatLogBtn.addEventListener('click', () => {
          const isHidden = (eventLogCard.style.display === 'none');
          eventLogCard.style.display = isHidden ? 'block' : 'none';
          floatLogBtn.textContent = isHidden ? 'Hide Event Log' : 'Show Event Log';
        });
      }
      if (floatImeBtn) {
        floatImeBtn.addEventListener('click', () => {
          disableIME = !disableIME;
          const editor = document.getElementById('text-editor');
          if (editor) {
            if (disableIME) editor.classList.add('disable-ime');
            else editor.classList.remove('disable-ime');
          }
          floatImeBtn.innerHTML = `
            <i class="fas fa-keyboard"></i>
            IME Shortcuts: ${disableIME ? 'OFF' : 'ON'}
          `;
        });
      }

      // æ·»åŠ æ¸…é™¤æŒ‰é’®åŠŸèƒ½
      const clearButton = document.getElementById('clear-text-button');
      if (clearButton) {
        clearButton.addEventListener('click', function() {
          const simpleEditor = document.getElementById('simple-editor');
          if (simpleEditor) {
            const currentContent = simpleEditor.innerHTML;
            if (currentContent.trim() !== '') {
              simpleUndoStack.push('');
              simpleEditor.innerHTML = '';
              simpleEditor.focus();
              updateUndoButtonState();
            }
          }
        });
      }
    };

    // æ·»åŠ å½•éŸ³çŠ¶æ€åé¦ˆå‡½æ•°
    function showRecordingFeedback(isRecording) {
      // æ›´æ–°éº¦å…‹é£çŠ¶æ€æ–‡æœ¬
      if (micStatusSpan) {
        micStatusSpan.innerHTML = isRecording ? "ğŸŸ¢ Recording..." : "ğŸ”´ Stopped";
        micStatusSpan.className = isRecording ? "recording-active" : "";
      }
      
      // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºåœ†ç‚¹å’Œéº¦å…‹é£å›¾æ ‡
      const dots = document.querySelectorAll('.recording-status-dot');
      const micIcons = document.querySelectorAll('.mic-icon');
      
      if (isRecording) {
        dots.forEach(dot => {
          dot.classList.remove('stopped');
          dot.classList.add('recording');
        });
        micIcons.forEach(icon => {
          icon.classList.add('recording');
        });
      } else {
        dots.forEach(dot => {
          dot.classList.remove('recording');
          dot.classList.add('stopped');
        });
        micIcons.forEach(icon => {
          icon.classList.remove('recording');
        });
        
        // ç§»é™¤å…‰æ ‡
        removeCursor();
      }
    }

    // åœæ­¢å½•éŸ³çš„å‡½æ•°
    function stopRecording() {
      if (recognition) {
        try { 
          recognition.onend = null; // é˜²æ­¢onendè§¦å‘finalizeTapSay
          recognition.stop(); 
        } catch(e) { 
          console.error(e); 
        }
      }
      
      // æ¸…ç†çŠ¶æ€
      isRecording = false;
      isListening = false;
      
      // æ›´æ–°UI
      if (micStatusSpan) {
        micStatusSpan.innerHTML = "ğŸ”´ Stopped";
        micStatusSpan.className = "";
      }
      
      // æ›´æ–°éº¦å…‹é£å›¾æ ‡çŠ¶æ€
      const dots = document.querySelectorAll('.recording-status-dot');
      const micIcons = document.querySelectorAll('.mic-icon');
      dots.forEach(dot => {
        dot.classList.remove('recording');
      });
      micIcons.forEach(icon => {
        icon.classList.remove('recording');
      });
    }

    // Handle speech recognition results, add relative position parameter
    function handleRecognitionResult(transcript, relativePosition = 0) {
      if (!transcript || !transcript.trim()) return;
      
      // Convert speech recognition results to lowercase
      const lowerCaseTranscript = transcript.toLowerCase();
      
      console.log("Processing voice command, relative position:", relativePosition);
      console.log("Original transcript:", transcript);
      console.log("Lowercase transcript:", lowerCaseTranscript);
      
      // Process voice commands
      try {
        // Check if there is an AI message processing function
        if (typeof proceedWithAI === 'function') {
          // Pass relative position information to AI processing function
          console.log("Using proceedWithAI, relative position:", relativePosition);
          proceedWithAI(originalSentence, lowerCaseTranscript, relativePosition);
        } else {
          // Apply simple replacement directly
          if (activeMode === MODE_EXPERIENCE) {
            // In Transcription mode, use the currently selected sentence and voice input
            console.log("Using applyCorrection, relative position:", relativePosition);
            applyCorrection(selectedSentence, lowerCaseTranscript, relativePosition);
          } else if (activeMode === MODE_INPUT) {
            // Free input mode should use finalizeTapSay which will call API
            voiceInputSpan.innerText = transcript;
            errorText.innerText = originalSentence;
            finalOutputSpan.innerText = transcript;
            // Let the API handle the correction via finalizeTapSay (called by recognition.onend)
          }
        }
      } catch (error) {
        console.error("Error processing voice command:", error);
      }
    }

    // Add applyCorrection function, adapt to new relative position parameter
    function applyCorrection(sentence, transcript, relativePosition = 0) {
      console.log("Applying correction, original:", sentence, "correction:", transcript, "relative position:", relativePosition);
      
      // Build merged string
      const mergedStr = sentence + " || " + transcript;
      
      // Use the incoming relative position directly, no need to add startIndex
      // Because the API needs relative position rather than absolute position
      let finalPosition = relativePosition;
      
      console.log("Sending to API with position:", finalPosition);
      
      // Call API
      sendToAPI(mergedStr, finalPosition, activeMode === MODE_EXPERIENCE);
    }
  </script>
</body>
</html>