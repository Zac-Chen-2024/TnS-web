<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Ensure proper scaling on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tap&amp;Say Text Editor</title>
  <style>
    /* Global Basic Styles */
    html, body {
      margin: 0; 
      padding: 0;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      overflow-x: hidden;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e9f2 100%);
      min-height: 100vh;  /* ç¡®ä¿èƒŒæ™¯è‰²å¡«å……æ•´ä¸ªè§†çª—é«˜åº¦ */
    }

    /* ç§»é™¤æ‰€æœ‰å®¹å™¨çš„é»˜è®¤è¾¹è· */
    .container, #app {
      margin: 0;
      padding: 0;
      width: 100%;
    }

    /* Header/Footer containers */
    #header-container, #footer-container {
      width: 100%;
      text-align: center;
      margin: 0;
    }
    #header-container h1 {
      margin: 0;
    }

    /* Mode buttons container */
    #mode-buttons {
      width: 90%;
      max-width: 800px;
      margin: 2rem auto;
      padding: 0;
      background: transparent;
      box-shadow: none;
      display: flex;
      justify-content: space-between;
      gap: 20px;
    }

    /* Container + Card Layout */
    .container {
      flex: 1;
      width: 90%;
      max-width: 800px;
      margin: 0 auto;
    }
    .card {
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      background: white;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
      overflow: hidden; /* é˜²æ­¢å†…å®¹æº¢å‡º */
    }
    /* ç§»é™¤å¡ç‰‡çš„hoveræ•ˆæœ */
    .card:hover,
    .mode-button:hover {
      transform: none;
    }

    /* ========== Editor ========== */
    #text-editor {
      width: 100%;
      min-height: 300px;
      border: 2px solid #e2e8f0;
      padding: 1.5rem;
      border-radius: 12px;
      outline: none;
      font-size: 1.1rem;
      line-height: 1.6;
      color: #2d3748;
      background: white;
      white-space: pre-wrap;
      transition: all 0.3s ease;
      -webkit-touch-callout: default; /* allow touch menu */
      box-sizing: border-box; /* ç¡®ä¿paddingä¸ä¼šå¯¼è‡´å®½åº¦æº¢å‡º */
      max-width: 100%; /* ç¡®ä¿ä¸ä¼šè¶…å‡ºçˆ¶å®¹å™¨ */
    }
    #text-editor:focus {
      border-color: #4299e1;
      box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.15);
      outline: none !important;  /* å»é™¤å¯èƒ½çš„é»˜è®¤outline */
    }
    #text-editor:empty:before {
      content: "Use voice transcription to text to input, use Tap&Say to modify";
      color: gray;
    }

    /* Highlighted Sentence */
    .highlighted-sentence {
      background-color: yellow;
    }

    /* Recording / Event Log, etc. */
    #mic-status {
      font-weight: bold;
      color: red;
    }
    #event-log {
      font-size: 14px;
      max-height: 200px;
      overflow-y: auto;
      background: #f9f9f9;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    /* Spinner Animation */
    @keyframes spin {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }
    .spinner {
      width: 150px;
      height: 150px;
      border: 8px solid #ccc;
      border-top-color: #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      position: relative;
      top: 0;
      left: 0;
    }

    /* Floating Suggestion Box */
    .suggestions-box-floating {
      position: fixed; /* æ”¹ä¸ºfixedä»¥ç¡®ä¿æ­£ç¡®å®šä½ */
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 8px;
      z-index: 2000;
      user-select: none;
      pointer-events: auto;
      min-width: 200px;
      max-width: 300px;
      max-height: 150px;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .suggestions-box-floating .suggestion-item {
      padding: 8px 12px;
      margin: 4px 0;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
      line-height: 1.4;
      color: #2d3748;
      background: #f8f9fa;
    }
    .suggestions-box-floating .suggestion-item:hover {
      background: #edf2f7;
    }
    .suggestions-box-floating .suggestion-item:active {
      background: #e2e8f0;
    }

    /* Toast Notification */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 12px 24px;
      border-radius: 5px;
      z-index: 3000;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    /* æ–°çš„modeæŒ‰é’®æ ·å¼ */
    .mode-button {
      flex: 1;
      padding: 1.5rem;
      border: none;
      border-radius: 12px;
      background: white;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
      cursor: pointer;
      font-size: 1.25rem;  /* å¢å¤§å­—ä½“å¤§å° */
      font-weight: 500;    /* ç¨å¾®åŠ ç²— */
      color: #4a5568;      /* æ·±ç°è‰²æ–‡å­— */
      transition: all 0.3s ease;
    }
    .mode-button.active {
      background: #4299e1;
      color: white;
      font-weight: 600;    /* æ¿€æ´»çŠ¶æ€å­—ä½“æ›´ç²— */
    }
    .mode-button:hover:not(.active) {
      background: #f7fafc;
      transform: translateY(-1px);
    }

    /* Editor suggestions in free-input mode */
    #editor-suggestions {
      margin-bottom: 10px;
    }
    #editor-suggestions h4 {
      margin: 0 0 8px 0;
      color: #4a5568;
      font-size: 1rem;
      font-weight: 500;
    }
    #editor-suggestions .suggestion-item {
      padding: 10px;
      margin: 8px 0;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      min-height: 24px;
      background-color: #fff;
      cursor: pointer;
      display: none; /* é»˜è®¤éšè—ï¼Œç­‰æœ‰å€™é€‰æ—¶å†æ˜¾ç¤º */
    }

    /* Footer æ ·å¼ä¼˜åŒ– */
    #footer-container {
      text-align: center;
      padding: 2rem;
      color: #718096;
      margin-top: 3rem;
    }

    /* Experience mode skip buttonæ–‡æœ¬ */
    #skip-sentence-button {
      content: "Press and hold near the error until highlighted, then speak your correction";
    }
    #skip-sentence-button.success {
      content: "Well done! Next sentence";
    }

    .tip-box {
      background: #f8f9fa;
      border-left: 4px solid #007bff;
      padding: 12px 16px;
      margin-bottom: 16px;
      border-radius: 4px;
      font-size: 14px;
      color: #495057;
    }
    .tip-content {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .tip-content i {
      color: #ffc107;
    }

    /* ç›®æ ‡å¥/é”™è¯¯å¥ï¼šå»æ‰ç§»åŠ¨ç«¯é•¿æŒ‰å‡ºç°çš„ç°è‰²è¾¹æ¡†æˆ–æ°´æ³¢çº¹ */
    #target-sentence, #error-sentence {
      -webkit-tap-highlight-color: transparent !important;
      outline: none !important;
      box-shadow: none !important;
      pointer-events: auto;
    }
    #target-sentence:focus, #error-sentence:focus {
      outline: none !important;
      box-shadow: none !important;
    }

    /* textareaæ•´ä½“æ ·å¼ï¼ˆä½“éªŒæ¨¡å¼ï¼‰ */
    #target-sentence, #error-sentence {
      width: 100%;
      min-height: 60px;
      padding: 10px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
      line-height: 1.5;
      resize: none;
      background-color: white;
      box-sizing: border-box;
      margin: 8px 0;
      font-family: inherit;
    }
    /* ç›®æ ‡å¥ç‰¹æœ‰æ ·å¼ */
    #target-sentence {
      cursor: default;
      user-select: text;
      background-color: #f8f9fa;  /* ç¨å¾®ç°ä¸€ç‚¹çš„èƒŒæ™¯è‰²ä»¥åŒºåˆ† */
    }
    /* é”™è¯¯å¥ç‰¹æœ‰æ ·å¼ */
    #error-sentence {
      cursor: text;
    }

    /* ç§»åŠ¨ç«¯è‡ªé€‚åº” */
    @media screen and (max-width: 768px) {
      .container, #mode-buttons {
        width: 90%;
        margin: 6px auto;
      }

      #mode-buttons {
        gap: 6px;
      }

      /* å¡ç‰‡æ ·å¼ç´§å‡‘åŒ– */
      .card {
        padding: 8px;
        margin-bottom: 8px;
      }
      .card h3 {
        margin: 0 0 6px 0;
        font-size: 0.9rem;
      }

      #target-sentence, 
      #error-sentence {
        padding: 6px;
        margin: 4px 0;
        min-height: 40px;
        font-size: 0.9rem;
      }

      .card p {
        margin: 4px 0;
        font-size: 0.9rem;
      }

      #other-suggestions {
        margin: 6px 0;
        padding: 6px;
      }
      #other-suggestions h4 {
        margin: 0 0 4px 0;
        font-size: 0.9rem;
      }
      .suggestion-item {
        padding: 6px;
        margin: 3px 0;
        min-height: 18px;
        font-size: 0.9rem;
      }

      div[style*="justify-content: space-between"] {
        margin: 6px 0 !important;
      }

      div[style*="display: flex; gap: 10px;"] {
        display: flex;
        justify-content: flex-end !important; /* é å³ */
        gap: 8px !important;
        margin-top: 8px;
      }

      #experience-undo-button, #skip-sentence-button {
        font-size: 14px;
        padding: 8px 12px;
        flex: 0 0 auto;
      }
    }
  </style>
</head>
<body>
  <header id="header-container">
  </header>

  <!-- Mode Switch Buttons -->
  <div id="mode-buttons">
    <button id="mode-experience" class="mode-button active">Experience Mode</button>
    <button id="mode-input" class="mode-button">Free Input Mode</button>
  </div>

  <!-- ç¬¬äºŒæ’æŒ‰é’®ï¼šShow Monitoring, Show Event Log, IME toggle -->
  <div id="mode-buttons" style="margin-top: 10px;">
    <button id="toggle-monitoring" class="mode-button" style="
      background: #007bff;
      color: #fff;
      font-size: 14px;
    ">Show Monitoring</button>
    <button id="toggle-log" class="mode-button" style="
      background: #007bff;
      color: #fff;
      font-size: 14px;
    ">Show Event Log</button>
    <button id="toggle-ime" class="mode-button" style="
      background: #007bff;
      color: #fff;
      font-size: 14px;
    ">IME Shortcuts (Mobile): OFF</button>
  </div>

  <div class="container">
    <!-- Monitoring Area -->
    <div class="card" id="monitoring-card" style="display: none;">
      <p><strong>Error Sentence:</strong> <span id="error-text">None</span></p>
      <p><strong>Original Error Sentence:</strong> <span id="original-error-sentence">None</span></p>
      <p><strong>Touch Index (relative):</strong> <span id="touch-index">None</span></p>
      <p><strong>Speech Input:</strong> <span id="voice-input">None</span></p>
      <p><strong>Final Output:</strong> <span id="final-output">None</span></p>
      <p><strong>Recording Status:</strong> <span id="mic-status">ğŸ”´ Stopped</span></p>
    </div>

    <!-- Editor + Undo Button -->
    <div class="card" id="input-mode">
      <h3>Tap&amp;Say Text Editor</h3>
      <!-- è‡ªç”±è¾“å…¥æ¨¡å¼çš„å»ºè®®åŒºåŸŸ -->
      <div id="editor-suggestions">
        <h4>Tap&Say Top-2,3 Suggestions:</h4>
        <div class="suggestion-item"></div>
        <div class="suggestion-item"></div>
      </div>

      <div id="text-editor" contenteditable="true"></div>

      <button id="undo-button" style="
        margin-top: 12px;
        width: 100%;
        padding: 14px;
        font-size: 16px;
        border: none;
        border-radius: 6px;
        background: #28a745;
        color: #fff;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        cursor: pointer;
      ">Undo Last Change</button>
    </div>

    <!-- Experience Mode -->
    <div class="card" id="experience-mode" style="display: none;">
      <h3>Experience Mode</h3>
      <div class="card">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <button class="nav-button" id="prev-sentence" style="visibility: hidden;">â†</button>
          <span id="sentence-index">1/5</span>
          <button class="nav-button" id="next-sentence">â†’</button>
        </div>
        <p><strong>Target Sentence:</strong></p>
        <textarea id="target-sentence" readonly></textarea>
        <p><strong>Error Sentence:</strong></p>
        <textarea id="error-sentence" readonly></textarea>

        <div id="other-suggestions" class="suggestions-box">
          <h4>Other Suggestions:</h4>
          <div class="suggestion-item"></div>
          <div class="suggestion-item"></div>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 12px;">
          <button id="experience-undo-button" style="
            flex: 1;
            padding: 14px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #28a745;
            color: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
          ">Restore Original Error</button>
          <button id="skip-sentence-button" style="
            flex: 1;
            padding: 14px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #6c757d;
            color: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
          ">Press and hold near the error until highlighted, then speak your correction</button>
        </div>
        <button id="next-pair-button" style="
          width: 100%;
          margin-top: 10px;
          padding: 14px;
          font-size: 16px;
          border: none;
          border-radius: 6px;
          background: #007bff;
          color: #fff;
          box-shadow: 0 2px 6px rgba(0,0,0,0.2);
          cursor: pointer;
          display: none;
        ">Next Sentence</button>
      </div>
    </div>

    <!-- Event Log Area -->
    <div class="card" id="event-log-card" style="display: none;">
      <h3>Event Log</h3>
      <div id="event-log">No events recorded</div>
    </div>
  </div>

  <script>
    /*******************************************************
     * 1) Global constants for API endpoints
     *******************************************************/
    const API_URL = "https://tns.zacchen.win/correct";
    const PUNCTUATION_API_URL = "https://tns.zacchen.win/restore_punctuation";

    /*******************************************************
     * 2) Monitoring / Event Log / IME toggles
     *******************************************************/
    let disableIME = false;
    const monitoringCard = document.getElementById("monitoring-card");
    const eventLogCard = document.getElementById("event-log-card");

    const monitoringBtn = document.getElementById("toggle-monitoring");
    const eventLogBtn = document.getElementById("toggle-log");
    const imeBtn = document.getElementById("toggle-ime");
    monitoringBtn.addEventListener("click", () => {
      monitoringCard.style.display = (monitoringCard.style.display === "none") ? "block" : "none";
      monitoringBtn.innerText = (monitoringCard.style.display === "none") ? "Show Monitoring" : "Hide Monitoring";
    });
    eventLogBtn.addEventListener("click", () => {
      eventLogCard.style.display = (eventLogCard.style.display === "none") ? "block" : "none";
      eventLogBtn.innerText = (eventLogCard.style.display === "none") ? "Show Event Log" : "Hide Event Log";
    });
    imeBtn.addEventListener("click", () => {
      disableIME = !disableIME;
      imeBtn.innerText = disableIME ? "IME Shortcuts (Mobile): ON" : "IME Shortcuts (Mobile): OFF";
      document.getElementById("text-editor").style.webkitTouchCallout = disableIME ? "none" : "default";
    });

    /*******************************************************
     * 3) Other global variables
     *******************************************************/
    let selectOverlay = null;
    let overlayTimer = null;
    let pressTimer = null;
    let tapTriggered = false;
    let globalTapIndex = -1;  // Absolute index in the full text
    let localTapIndex = -1;   // Relative index in the selected sentence
    let initialX = 0, initialY = 0;
    let currentMode = null;   // "tap" or "voice"
    let recognition = null;
    let isListening = false;
    let silenceTimer = null;
    let savedRange = null;    // For saving/restoring the cursor position
    let originalSentence = "";
    let suggestionsBox = null;
    let suggestionsTimer = null;
    let undoStack = [];
    let isUserTyping = false; // æ ‡å¿—ç”¨æˆ·æ˜¯å¦åœ¨è¾“å…¥
    let lastHighlightedSentence = "";
    let shouldMoveCaret = false;
    let highlightTimeout = null;
    let currentHighlightedSentence = "";
    let initialErrorSentence = '';
    let currentOriginalErrorSentence = '';
    let currentTapSayTarget = '';
    let currentSentenceState = '';

    const editor = document.getElementById("text-editor");
    const errorText = document.getElementById("error-text");
    const originalErrorSpan = document.getElementById("original-error-sentence");
    const touchIndexSpan = document.getElementById("touch-index");
    const voiceInputSpan = document.getElementById("voice-input");
    const micStatusSpan = document.getElementById("mic-status");
    const finalOutputSpan = document.getElementById("final-output");
    const eventLog = document.getElementById("event-log");
    const undoButton = document.getElementById("undo-button");

    // å®šä¹‰å¥å­å’Œæç¤º
    const sentencePairs = [
      {
        target: "Your best bet is to drop him and go after another player.",
        error: "Your best bet is to drop him and go after another.",
        tip: "Press and hold near the error until the sentence is highlighted, then speak your correction"
      },
      {
        target: "The team needs to focus on developing young talents.",
        error: "The team needs to focus on develop young talents.",
        tip: "Well done! Let's try another one"
      },
      {
        target: "She has been living in Paris for the past five years.",
        error: "She has lived in Paris since five years.",
        tip: "For multiple errors, you can make corrections multiple times"
      },
      {
        target: "The cat sat on the mat. The dog chased the cat. The mouse ran away quickly.",
        error: "The cat sat on the mat. The dog chase the cat. The mouse ran away quickly.",
        tip: "This feature also works within paragraphs"
      },
      {
        target: "They were discussing the implications of the new policy.",
        error: "They were discuss about the implications of the new policy.",
        tip: "If the first suggestion isn't what you want, you can select the correct one from the candidates"
      }
    ];

    let currentPairIndex = 0; // å½“å‰å¥å­ç´¢å¼•

    /*******************************************************
     * 4) onload: Load header/footer and get mic access
     *******************************************************/
    window.onload = function(){
      loadHeaderFooter();
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({audio:true})
          .catch(err => {
            showToast("Please allow microphone access to use Tap&Say.");
            console.warn("Mic permission error:", err);
          });
      }

      // åˆå§‹åŒ–ä½“éªŒæ¨¡å¼å†…å®¹
      initializeExperienceMode();
      
      // é»˜è®¤æ˜¾ç¤ºä½“éªŒæ¨¡å¼ï¼Œå¹¶æ¿€æ´»å¯¹åº”æŒ‰é’®
      document.getElementById("input-mode").style.display = "none";
      document.getElementById("experience-mode").style.display = "block";
      document.getElementById("mode-experience").classList.add("active");
      document.getElementById("mode-input").classList.remove("active");
    };

    async function loadHeaderFooter(){
      try {
        // åªåŠ è½½é¡µçœ‰
        const headerRes = await fetch("header.html");
        const headerHtml = await headerRes.text();
        document.getElementById("header-container").innerHTML = headerHtml;
      } catch(e) {
        console.warn("Failed to load header:", e);
      }
    }

    /*******************************************************
     * 5) Toast and Event Log
     *******************************************************/
    function showToast(msg){
      const t = document.createElement("div");
      t.className = "toast";
      t.innerText = msg;
      document.body.appendChild(t);
      requestAnimationFrame(() => { t.style.opacity = 1; });
      setTimeout(() => {
        t.style.opacity = 0;
        setTimeout(() => { t.remove(); }, 500);
      }, 2000);
    }
    function logEvent(message){
      const p = document.createElement("p");
      const now = new Date().toLocaleString("en-US", { hour12: false });
      p.innerText = `[${now}] ${message}`;
      eventLog.appendChild(p);
    }

    /*******************************************************
     * 6) File Drag & Drop
     *******************************************************/
    ["dragenter", "dragover", "dragleave", "drop"].forEach(evtName => {
      editor.addEventListener(evtName, e => {
        e.preventDefault();
        e.stopPropagation();
      }, false);
    });
    editor.addEventListener("dragover", () => { editor.style.background = "#fafafa"; });
    editor.addEventListener("dragleave", () => { editor.style.background = "white"; });
    editor.addEventListener("drop", e => {
      editor.style.background = "white";
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        const fname = file.name.toLowerCase();
        if (fname.endsWith(".txt") || fname.endsWith(".doc")) {
          let reader = new FileReader();
          reader.onload = function(evt) {
            editor.innerText = evt.target.result;
            logEvent("File loaded: " + file.name);
          };
          reader.readAsText(file, "UTF-8");
        } else {
          showToast("Only .txt or .doc files are supported.");
        }
      }
    });

    /*******************************************************
     * 7) Long Press in free input mode
     *******************************************************/
    editor.addEventListener("mousedown", (e) => {
      // åªåœ¨è‡ªç”±è¾“å…¥æ¨¡å¼ç”Ÿæ•ˆ
      if (document.getElementById("input-mode").style.display === "none") return;
      
      tapTriggered = false;
      globalTapIndex = getCaretIndex(e.clientX, e.clientY);
      initialX = e.clientX;
      initialY = e.clientY;
      
      pressTimer = setTimeout(() => {
        tapTriggered = true;
        handleSelection("tap");
      }, 600);
    });
    editor.addEventListener("mouseup", (e) => {
      if (pressTimer) clearTimeout(pressTimer);
      tapTriggered = false;
    });
    editor.addEventListener("mouseleave", (e) => {
      if (pressTimer) clearTimeout(pressTimer);
      tapTriggered = false;
    });
    editor.addEventListener("touchstart", (e) => {
      if (document.getElementById("input-mode").style.display === "none") return;
      tapTriggered = false;
      const touch = e.touches[0];
      globalTapIndex = getTouchIndex(touch.clientX, touch.clientY);
      initialX = touch.clientX;
      initialY = touch.clientY;
      
      pressTimer = setTimeout(() => {
        tapTriggered = true;
        handleSelection("tap");
      }, 1000);
    });
    editor.addEventListener("touchend", (e) => {
      if (pressTimer) clearTimeout(pressTimer);
      tapTriggered = false;
    });
    editor.addEventListener("touchcancel", (e) => {
      if (pressTimer) clearTimeout(pressTimer);
      tapTriggered = false;
    });
    function getTouchIndex(x, y){
      let rect = editor.getBoundingClientRect();
      let relativeX = x - rect.left;
      let totalChars = editor.innerText.length;
      if (totalChars === 0) return 0;
      let ratio = relativeX / rect.width;
      ratio = Math.max(0, Math.min(1, ratio));
      return Math.floor(ratio * totalChars);
    }

    /*******************************************************
     * 8) Handle selection (Tap/Voice)
     *******************************************************/
    function handleSelection(mode) {
      removeSuggestionsBox();
      currentMode = "tap";

      let { sentence, relativeIndex } = getSelectedSentenceAndRelativeIndex(editor.innerText, globalTapIndex);
      sentence = sentence.trim();
      if (!sentence) {
        logEvent("No valid sentence found for highlight");
        return;
      }

      currentTapSayTarget = sentence;
      currentSentenceState = sentence;
      localTapIndex = relativeIndex;
      touchIndexSpan.innerText = localTapIndex.toString();

      errorText.innerText = sentence;
      originalSentence = sentence;
      originalErrorSpan.innerText = sentence;
      undoStack.push(editor.innerHTML);

      removeHighlight();
      if (!highlightSentence(sentence)) {
        logEvent("Highlight not found in editor => " + sentence);
      }

      setTimeout(() => {
        moveCaretToEndOfTarget();
        editor.focus();
      }, 50);

      startRecording();
    }

    /*******************************************************
     * 9) highlight / removeHighlight / replace
     *******************************************************/
    function highlightSentence(sentence){
      lastHighlightedSentence = sentence;
      let html = editor.innerHTML;
      let safe = sentence.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const re = new RegExp(safe, "i");
      if (!re.test(html)) return false;
      editor.innerHTML = html.replace(re, `<span id="target-sentence" class="highlighted-sentence">$&</span>`);
      return true;
    }
    function removeHighlight(){
      let html = editor.innerHTML;
      html = html.replace(/<span id="target-sentence" class="highlighted-sentence">(.*?)<\/span>/i, "$1");
      editor.innerHTML = html;
      moveCaretToEndOfTarget();
    }
    function replaceHighlightedSentence(newText){
      let ts = document.getElementById("target-sentence");
      if (ts) {
        ts.innerText = newText;
      } else {
        // fallback
        let textContent = editor.innerText;
        if (currentTapSayTarget) {
          editor.innerText = textContent.replace(currentTapSayTarget, newText);
        }
      }
      // æ›´æ–° currentTapSayTarget
      currentTapSayTarget = newText;
    }

    /*******************************************************
     * 10) Start speech recognition
     *******************************************************/
    function startRecording(){
      if (!("SpeechRecognition" in window) && !("webkitSpeechRecognition" in window)) {
        showToast("Speech recognition not supported in this browser.");
        finalizeTapSay();
        return;
      }
      let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = "en-US";

      recognition.onstart = () => {
        isListening = true;
        micStatusSpan.innerText = "ğŸŸ¢ Recording...";
        silenceTimer = setTimeout(() => {
          if (isListening) recognition.stop();
        }, 5000);
      };
      recognition.onresult = (e) => {
        clearTimeout(silenceTimer);
        let txt = "";
        for (let i = e.resultIndex; i < e.results.length; i++){
          txt += e.results[i][0].transcript;
        }
        voiceInputSpan.innerText = txt;
      };
      recognition.onerror = (err) => {
        micStatusSpan.innerText = "âŒ Recording error";
        if (isListening) recognition.stop();
        logEvent("Speech recognition error => " + err.error);
      };
      recognition.onend = () => {
        isListening = false;
        micStatusSpan.innerText = "ğŸ”´ Stopped";
        finalizeTapSay();
      };
      recognition.start();
    }

    /*******************************************************
     * 11) finalizeTapSay
     *******************************************************/
    function finalizeTapSay(){
      removeOverlay();
      removeSuggestionsBox();
      let transcript = voiceInputSpan.innerText.trim();
      if (!transcript) {
        showToast("No speech input detected.");
        currentTapSayTarget = '';
        currentMode = null;
        return;
      }

      if (currentMode === "tap" && currentTapSayTarget) {
        let textNoPunc = removePunctuation(transcript).trimEnd();
        let merged = (currentTapSayTarget + " <||> " + textNoPunc).trimEnd();
        finalOutputSpan.innerText = merged;
        logEvent("Final output => " + merged);

        // åœ¨ä½“éªŒæ¨¡å¼ä¸‹å‘é€åˆ°API
        if (document.getElementById("experience-mode").style.display !== "none") {
          sendToAPI(merged, localTapIndex, true);
        } else {
          sendToAPI(merged, localTapIndex, false);
        }
      }

      currentMode = null;
      voiceInputSpan.innerText = "";
    }

    /*******************************************************
     * 12) /correct API call
     *******************************************************/
    function sendToAPI(mergedStr, loc, isExperienceMode = false){
      logEvent("Sending /correct => merged_string:" + mergedStr + ", touch_location:" + loc);
      fetch(API_URL, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          merged_string: mergedStr,
          touch_location: loc
        })
      })
      .then(resp => resp.json())
      .then(data => {
        let corrs = data.corrections || [];
        logEvent("API corrections => " + JSON.stringify(corrs));
        removeOverlay();
        applyFirstSuggestionAndShowBox(corrs, isExperienceMode);
      })
      .catch(err => {
        logEvent("API call error => " + err);
        removeOverlay();
      });
    }

    /*******************************************************
     * 13) applyFirstSuggestionAndShowBox
     *******************************************************/
    function applyFirstSuggestionAndShowBox(corrections, isExperienceMode = false) {
      if (!corrections.length) {
        return;
      }
      console.log("applyFirstSuggestionAndShowBox => corrections:", corrections);
      
      let candidate = corrections[0].trimEnd();

      if (isExperienceMode) {
        /**** ä½“éªŒæ¨¡å¼é€»è¾‘ ****/
        const errorSentence = document.getElementById("error-sentence");
        const suggestionItems = document.querySelectorAll('#other-suggestions .suggestion-item');
        
        if (errorSentence) {
          // æ›¿æ¢ç¬¬1æ¡
          const fullText = errorSentence.value;
          const index = fullText.indexOf(currentTapSayTarget);
          if (index !== -1) {
            // ç”¨ candidate æ›¿æ¢
            const newText = fullText.slice(0, index) + candidate + fullText.slice(index + currentTapSayTarget.length);
            errorSentence.value = newText;
            currentTapSayTarget = candidate;

            // æ›´æ–°ç¬¬2å’Œç¬¬3æ¡
            for (let i = 1; i < corrections.length && i <= 2; i++) {
              let item = suggestionItems[i - 1];
              if (item) {
                item.style.display = 'block';
                item.textContent = corrections[i].trimEnd();
                item.onclick = () => {
                  let chosen = corrections[i].trimEnd();
                  const newText2 = errorSentence.value.replace(candidate, chosen);
                  errorSentence.value = newText2;
                  currentTapSayTarget = chosen;
                  checkCompletion();
                };
              }
            }
            checkCompletion();
          }
        }
      } else {
        /**** è‡ªç”±è¾“å…¥æ¨¡å¼é€»è¾‘ ****/
        // 1) è‡ªåŠ¨ç”¨ç¬¬ä¸€æ¡å»ºè®®æ›¿æ¢é«˜äº®çš„å¥å­
        replaceHighlightedSentence(candidate);

        // 2) å¦‚æœåªæœ‰1æ¡å»ºè®®ï¼Œå°±ä¸ç”¨æ˜¾ç¤ºå…¶ä»–
        const suggestionDivs = document.querySelectorAll("#editor-suggestions .suggestion-item");
        // å…ˆå…¨éƒ¨éšè—
        suggestionDivs.forEach(div => {
          div.style.display = "none";
          div.textContent = "";
        });

        if (corrections.length > 1) {
          for (let i = 1; i < corrections.length && i - 1 < suggestionDivs.length; i++) {
            let item = suggestionDivs[i - 1];
            item.style.display = "block";
            item.textContent = corrections[i].trimEnd();
            // ç‚¹å‡»åä¹Ÿè¦æ›¿æ¢
            item.onclick = () => {
              replaceHighlightedSentence(corrections[i].trimEnd());
            };
          }
        }
      }
    }

    /*******************************************************
     * 14) removeSuggestionsBox & endTapSay
     *******************************************************/
    function removeSuggestionsBox(){
      if (suggestionsBox) {
        if (suggestionsBox.parentElement) {
          suggestionsBox.parentElement.removeChild(suggestionsBox);
        }
        suggestionsBox = null;
      }
      if (suggestionsTimer) {
        clearTimeout(suggestionsTimer);
        suggestionsTimer = null;
      }
    }
    function endTapSay() {
      clearTimeout(highlightTimeout);
      removeHighlight();
      console.log("removeHighlight called.");
    }

    /*******************************************************
     * 15) Undo logic
     *******************************************************/
    undoButton.addEventListener("click", function(){
      if (undoStack.length > 0) {
        let prevState = undoStack.pop();
        editor.innerHTML = prevState;
        removeHighlight();
        showToast("Undo last change");
      } else {
        showToast("No change to undo!");
      }
      editor.focus();
    });

    /*******************************************************
     * 16) Utility Functions
     *******************************************************/
    function getCaretIndex(x, y){
      let range;
      if (document.caretRangeFromPoint) {
        range = document.caretRangeFromPoint(x, y);
      } else if (document.caretPositionFromPoint) {
        let pos = document.caretPositionFromPoint(x, y);
        if (!pos) return -1;
        range = document.createRange();
        range.setStart(pos.offsetNode, pos.offset);
        range.collapse(true);
      }
      if (!range) return -1;
      let pre = range.cloneRange();
      pre.selectNodeContents(editor);
      pre.setEnd(range.startContainer, range.startOffset);
      return pre.toString().length;
    }
    function removePunctuation(str){
      return str.replace(/[^a-zA-Z0-9'\s]/g, "");
    }
    function getSelectedSentenceAndRelativeIndex(text, clickPosition) {
      // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ä»¥.!?ç»“å°¾çš„å¥å­
      const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
      let currentPosition = 0;
      
      for (let sentence of sentences) {
        const endPosition = currentPosition + sentence.length;
        if (clickPosition >= currentPosition && clickPosition <= endPosition) {
          return {
            sentence: sentence.trim(),
            relativeIndex: clickPosition - currentPosition
          };
        }
        currentPosition = endPosition;
      }
      // å¦‚æœç‚¹å‡»ä½ç½®è¶…å‡ºäº†æœ€åä¸€å¥
      if (sentences.length > 0) {
        const lastSentence = sentences[sentences.length - 1];
        return {
          sentence: lastSentence.trim(),
          relativeIndex: clickPosition - (text.length - lastSentence.length)
        };
      }
      // é»˜è®¤è¿”å›æ•´ä¸ªæ–‡æœ¬
      return {
        sentence: text.trim(),
        relativeIndex: clickPosition
      };
    }
    function moveCaretToEndOfTarget(){
      setTimeout(() => {
        const ts = document.getElementById("target-sentence");
        if (!ts && lastHighlightedSentence) {
          const range = document.createRange();
          const sel = window.getSelection();
          const textNode = editor.firstChild;

          if (textNode) {
            const index = textNode.textContent.indexOf(lastHighlightedSentence);
            if (index !== -1) {
              range.setStart(textNode, index + lastHighlightedSentence.length);
              range.collapse(true);
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
        } else if (ts) {
          const range = document.createRange();
          const sel = window.getSelection();
          range.setStartAfter(ts);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
          editor.focus();
        }
      }, 0);
    }

    /*******************************************************
     * 17) Mode switching
     *******************************************************/
    const modeInput = document.getElementById("mode-input");
    const modeExperience = document.getElementById("mode-experience");
    const inputMode = document.getElementById("input-mode");
    const experienceMode = document.getElementById("experience-mode");

    modeInput.addEventListener("click", () => {
      inputMode.style.display = "block";
      experienceMode.style.display = "none";
      modeInput.classList.add("active");
      modeExperience.classList.remove("active");
    });
    modeExperience.addEventListener("click", () => {
      inputMode.style.display = "none";
      experienceMode.style.display = "block";
      modeExperience.classList.add("active");
      modeInput.classList.remove("active");      
      // ä¿å­˜åˆå§‹é”™è¯¯å¥
      const errorSentence = document.getElementById("error-sentence");
      if (errorSentence) {
        initialErrorSentence = errorSentence.value;
      }
    });

    /*******************************************************
     * 18) Experience Mode Setup
     *******************************************************/
    function initializeExperienceMode() {
      const experienceMode = document.getElementById("experience-mode");
      experienceMode.innerHTML = `
        <h3>Experience Mode</h3>
        <div class="card">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <button class="nav-button" id="prev-sentence" style="visibility: hidden;">â†</button>
            <span id="sentence-index">1/5</span>
            <button class="nav-button" id="next-sentence">â†’</button>
          </div>
          <p><strong>Target Sentence:</strong></p>
          <textarea id="target-sentence" readonly></textarea>
          <p><strong>Error Sentence:</strong></p>
          <textarea id="error-sentence" readonly></textarea>
          <div id="other-suggestions" class="suggestions-box">
            <h4>Other Suggestions:</h4>
            <div class="suggestion-item"></div>
            <div class="suggestion-item"></div>
          </div>
          <div style="display: flex; gap: 10px; margin-top: 12px;">
            <button id="experience-undo-button" style="
              flex: 1;
              padding: 14px;
              font-size: 16px;
              border: none;
              border-radius: 6px;
              background: #28a745;
              color: #fff;
              box-shadow: 0 2px 6px rgba(0,0,0,0.2);
              cursor: pointer;
            ">Restore Original Error</button>
            <button id="skip-sentence-button" style="
              flex: 1;
              padding: 14px;
              font-size: 16px;
              border: none;
              border-radius: 6px;
              background: #6c757d;
              color: #fff;
              box-shadow: 0 2px 6px rgba(0,0,0,0.2);
              cursor: pointer;
            ">Press and hold near the error until highlighted, then speak your correction</button>
          </div>
          <button id="next-pair-button" style="
            width: 100%;
            margin-top: 10px;
            padding: 14px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #007bff;
            color: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            display: none;
          ">Next Sentence</button>
        </div>
      `;
      updateSentencePair(0);
      attachEventListeners();
    }

    function attachEventListeners() {
      const prevSentence = document.getElementById("prev-sentence");
      const nextSentence = document.getElementById("next-sentence");
      const skipBtn = document.getElementById("skip-sentence-button");
      const nextPairBtn = document.getElementById("next-pair-button");
      const expUndoBtn = document.getElementById("experience-undo-button");
      if (!prevSentence || !nextSentence || !skipBtn || !nextPairBtn || !expUndoBtn) return;

      prevSentence.addEventListener("click", () => {
        if (currentPairIndex > 0) {
          currentPairIndex--;
          updateSentencePair(currentPairIndex);
        }
      });
      nextSentence.addEventListener("click", () => {
        if (currentPairIndex < sentencePairs.length - 1) {
          currentPairIndex++;
          updateSentencePair(currentPairIndex);
        }
      });
      skipBtn.addEventListener("click", () => {
        const errorSentence = document.getElementById("error-sentence");
        const targetSentence = document.getElementById("target-sentence");
        if (errorSentence && targetSentence && errorSentence.value.trim() === targetSentence.value.trim()) {
          if (currentPairIndex < sentencePairs.length - 1) {
            currentPairIndex++;
            updateSentencePair(currentPairIndex);
          } else {
            showToast("Congratulations on completing all sentences!");
          }
        }
      });
      nextPairBtn.addEventListener("click", () => {
        if (currentPairIndex < sentencePairs.length - 1) {
          currentPairIndex++;
          updateSentencePair(currentPairIndex);
        } else {
          showToast("Congratulations on completing all sentences!");
        }
      });
      expUndoBtn.addEventListener("click", () => {
        const errorSentence = document.getElementById("error-sentence");
        if (errorSentence && currentOriginalErrorSentence) {
          errorSentence.value = currentOriginalErrorSentence;
          showToast("Restored to original error sentence");
        }
      });

      // é•¿æŒ‰äº‹ä»¶ï¼ˆé”™è¯¯å¥ï¼‰
      const errorSentence = document.getElementById("error-sentence");
      if (errorSentence) {
        let pressTimer = null;
        errorSentence.addEventListener("mousedown", (e) => {
          pressTimer = setTimeout(() => handleLongPress(), 600);
        });
        errorSentence.addEventListener("mouseup", () => {
          clearTimeout(pressTimer);
        });
        errorSentence.addEventListener("mouseleave", () => {
          clearTimeout(pressTimer);
        });
        errorSentence.addEventListener("touchstart", (e) => {
          pressTimer = setTimeout(() => handleLongPress(), 1000);
        });
        errorSentence.addEventListener("touchend", () => {
          clearTimeout(pressTimer);
        });
        errorSentence.addEventListener("touchcancel", () => {
          clearTimeout(pressTimer);
        });
      }
    }

    function handleLongPress() {
      const errorSentence = document.getElementById("error-sentence");
      if (!errorSentence) return;

      const start = errorSentence.selectionStart || 0;
      const fullText = errorSentence.value;
      const { sentence, relativeIndex } = getSelectedSentenceAndRelativeIndex(fullText, start);

      currentTapSayTarget = sentence.trim();
      localTapIndex = relativeIndex;
      touchIndexSpan.innerText = localTapIndex.toString();

      errorText.innerText = currentTapSayTarget;
      originalErrorSpan.innerText = currentTapSayTarget;
      originalSentence = currentTapSayTarget;

      // é€‰ä¸­è¯¥å¥
      const sentenceStart = fullText.indexOf(currentTapSayTarget);
      if (sentenceStart !== -1) {
        errorSentence.setSelectionRange(sentenceStart, sentenceStart + currentTapSayTarget.length);
      }

      currentMode = "tap";
      startRecording();
    }

    function updateSentencePair(index) {
      const targetSentence = document.getElementById("target-sentence");
      const errorSentence = document.getElementById("error-sentence");
      const indexSpan = document.getElementById("sentence-index");
      const prevButton = document.getElementById("prev-sentence");
      const nextButton = document.getElementById("next-sentence");
      const skipButton = document.getElementById("skip-sentence-button");

      // æ¸…ç©º other-suggestions
      const suggestionItems = document.querySelectorAll('#other-suggestions .suggestion-item');
      suggestionItems.forEach(item => {
        item.textContent = '';
        item.style.display = 'block';
      });

      // ç§»é™¤æ—§çš„ tip-box
      const oldTip = document.querySelector('.tip-box');
      if (oldTip) oldTip.remove();

      // æ’å…¥æ–°çš„ tip-box
      const container = document.querySelector('#experience-mode');
      container.insertBefore(addTipBox(sentencePairs[index].tip), container.firstChild);

      // æ›´æ–°ç›®æ ‡å¥å’Œé”™è¯¯å¥
      if (targetSentence) targetSentence.value = sentencePairs[index].target;
      if (errorSentence) {
        errorSentence.value = sentencePairs[index].error;
        currentOriginalErrorSentence = sentencePairs[index].error;
      }

      if (indexSpan) indexSpan.textContent = `${index + 1}/5`;
      if (prevButton) prevButton.style.visibility = index === 0 ? "hidden" : "visible";
      if (nextButton) nextButton.style.visibility = index === sentencePairs.length - 1 ? "hidden" : "visible";

      skipButton.textContent = "Press and hold near the error until highlighted, then speak your correction";
      skipButton.style.background = "#6c757d";
      currentTapSayTarget = '';
      currentSentenceState = '';
    }

    function addTipBox(tip) {
      const tipBox = document.createElement('div');
      tipBox.className = 'tip-box';
      tipBox.innerHTML = `
        <div class="tip-content">
          <i class="fas fa-lightbulb"></i>
          ${tip}
        </div>
      `;
      return tipBox;
    }

    function checkCompletion() {
      const targetSentence = document.getElementById("target-sentence");
      const errorSentence = document.getElementById("error-sentence");
      const skipButton = document.getElementById("skip-sentence-button");
      if (!targetSentence || !errorSentence) return;

      if (errorSentence.value.trim() === targetSentence.value.trim()) {
        skipButton.textContent = "Well done! Next sentence";
        skipButton.style.background = "#28a745";
        showToast("Correct!");
      } else {
        skipButton.textContent = "Press and hold near the error until highlighted, then speak your correction";
        skipButton.style.background = "#6c757d";
      }
    }

  </script>
</body>
</html>
