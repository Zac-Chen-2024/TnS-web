<!DOCTYPE html>     
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Ensure proper scaling on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tap&Say Text Editor</title>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

  <style>
    /*******************************************************
     * 0) Page Layout: Sticky Footer + Gradient Background
     *******************************************************/
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      box-sizing: border-box;
      overflow-x: hidden;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      display: flex;
      flex-direction: column;
      min-height: 100vh; /* Ensure page is at least as tall as the viewport */
    }
    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e9f2 100%);
    }
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1.2rem 0; /* Reduce vertical padding */
    }
    #header-container, #footer-container {
      width: 100%;
      margin: 0;
      padding: 0;
      flex-shrink: 0;
    }
    .container {
      width: 85%;
      max-width: 900px; /* Limit maximum width */
      margin: 0 auto;
      box-sizing: border-box;
    }

    /* 调整卡片间距 */
    #monitoring-card {
      margin-bottom: 2rem !important;
    }
    #experience-mode, #input-mode {
      margin-bottom: 2rem !important;
    }
    #event-log-card {
      margin-top: 1rem !important;
    }
    /* 保持模式按钮和主体卡片的间距不变 */
    #mode-buttons {
      margin-bottom: 20px;
    }

    /*******************************************************
     * Additional Class for JS Dynamic Toggle:
     * Disable Long Press Menu / Text Selection
     *******************************************************/
    .disable-ime {
      -webkit-touch-callout: none; /* Disable iOS long press menu */
      -webkit-user-select: none;   /* Disable text selection on iOS */
      user-select: none;           /* Disable text selection on Android/PC */
    }

    /*******************************************************
     * 1) Mode Button Container (#mode-buttons):
     * Large Buttons with Rounded Corners
     *******************************************************/
    #mode-buttons {
      display: flex;
      justify-content: space-between; /* Align buttons to both ends */
      align-items: center;
      margin-bottom: 20px; /* Consistent spacing with other cards */
      gap: 15px; /* Space between buttons */
      width: 100%; /* Ensure width matches container */
    }
    .mode-button {
      flex: 1; /* Evenly distribute button space */
      max-width: calc(50% - 10px); /* Prevent buttons from becoming too wide */
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 15px;
      background: #ffffff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      cursor: pointer;
      font-size: 1rem;
      color: #4a5568;
      text-align: center;
      transition: all 0.3s ease;
    }
    .mode-button.active {
      background: #4299e1;
      color: #fff;
    }
    .mode-button:hover:not(.active) {
      background: #f7fafc;
      transform: translateY(-1px);
    }

    /*******************************************************
     * 2) Card (.card): Rounded Corners + Shadow
     *******************************************************/
    .card {
      border-radius: 15px;
      padding: 30px; /* Maintain consistent internal padding */
      margin-bottom: 20px; /* Reduce spacing between cards */
      background: #fff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      font-size: 1rem; /* Smaller base font size */
    }
    .card:last-child {
      margin-bottom: 0;
    }
    .card h3 {
      font-size: 1.5rem; /* Smaller title font size */
      margin-bottom: 1.2rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* 添加录音状态指示圆点样式 */
    .recording-status-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background-color: #666;  /* 默认为灰色 */
      display: inline-block;
      transition: background-color 0.3s ease;
      vertical-align: middle; /* 确保与文字对齐 */
      margin-left: 0; /* 移除左边距 */
    }

    .recording-status-dot.recording {
      background-color: #28a745;
      animation: pulse 2s infinite;
    }

    /* 添加麦克风图标样式 */
    .mic-icon {
      color: #666; /* 默认灰色 */
      transition: color 0.3s ease;
      margin-right: 0px !important; /* 减少右边距 */
    }

    .mic-icon.recording {
      color: #28a745; /* 录音时变绿色 */
    }

    /* 移除 stopped 类，因为默认就是灰色 */
    .recording-status-dot.stopped {
      background-color: #666;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.2);
        opacity: 0.8;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /*******************************************************
     * 3) #text-editor
     *******************************************************/
    #text-editor {
      width: 100%;
      min-height: 350px; /* Reduce minimum height */
      box-sizing: border-box;
      resize: vertical;      
      overflow: auto;        
      margin: 0 auto;
      background: #fff;      
      border: 2px solid #e2e8f0;
      border-radius: 15px;
      padding: 1.5rem;
      font-size: 1.1rem;
      line-height: 1.6;
      color: #2d3748;
      transition: border-color 0.3s, box-shadow 0.3s;
    }
    #text-editor:focus {
      border-color: #4299e1;
      box-shadow: 0 0 0 3px rgba(66,153,225,0.15);
    }
    #text-editor, 
    #text-editor * {
      outline: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }

    /*******************************************************
     * 4) Highlight Color: Light Blue
     *******************************************************/
    .highlighted-sentence {
      background-color: #cce7ff;
      transition: background 0.3s;
    }

    /*******************************************************
     * 5) Monitoring / Log: Rounded Corners + Clean
     *******************************************************/
    #mic-status {
      font-weight: bold;
      color: red;
    }
    #mic-status.recording {
      color: #28a745; /* Green */
    }
    #mic-status.recording-active {
      color: #28a745; /* Green */
    }
    #event-log {
      font-size: 0.9rem;
      max-height: 200px;
      overflow-y: auto;
      background: #f9f9f9;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    /*******************************************************
     * 6) Floating Suggestions Box: Modern Style
     *******************************************************/
    .suggestions-box-floating {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.15);
      padding: 6px;
      z-index: 2000;
      user-select: none;
      pointer-events: auto;
      max-height: 160px;
      overflow-y: auto;
      transition: all 0.3s ease;
    }
    .suggestions-box-floating div {
      padding: 10px 12px;
      margin-bottom: 4px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      background-color: rgba(176, 196, 255, 0.2); /* Light blue background */
      border-left: 3px solid rgba(65, 105, 225, 0.5); /* Add a left border */
    }
    .suggestions-box-floating div:nth-child(2n) {
      background-color: rgba(186, 159, 255, 0.2); /* Light purple background */
      border-left: 3px solid rgba(138, 43, 226, 0.5);
    }
    .suggestions-box-floating div:nth-child(3n) {
      background-color: rgba(255, 160, 160, 0.2); /* Light red background */
      border-left: 3px solid rgba(220, 20, 60, 0.5);
    }
    .suggestions-box-floating div:hover {
      transform: translateY(-2px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      background-color: rgba(178, 235, 242, 0.4); /* Slightly darker on hover */
    }
    .suggestions-box-floating div:active {
      transform: translateY(0);
    }

    /*******************************************************
     * 7) Toast: Fixed Bottom Notification
     *******************************************************/
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 12px 24px;
      border-radius: 5px;
      z-index: 3000;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    /*******************************************************
     * 8) Drawer: (Removed old drawer style, replaced by float menu)
     *******************************************************/

    /*******************************************************
     * 9) Tip Card: Colored Left Border + Rounded Corners
     *******************************************************/
    .tip-box {
      background: #f0f2f4; /* Darker background */
      border-left: 4px solid #007bff;
      padding: 12px 16px;
      margin-bottom: 16px;
      border-radius: 4px;
      font-size: 14px;
      color: #495057;
    }
    .tip-content {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 1.1rem;
      font-weight: normal; 
    }
    .tip-content i {
      color: #ffc107;
    }

    /* Enhanced styles for PC */
    @media (min-width: 481px) {
      .tip-content {
        font-size: 1.1rem;
      }
      
      #experience-mode .card {
        padding: 30px;
      }
      
      #experience-undo-button,
      #skip-sentence-button {
        padding: 20px !important;
        font-size: 1.2rem !important;
      }
      
      #target-sentence,
      #error-sentence {
        font-size: 1.3rem;
        line-height: 1.8;
      }
      
      #sentence-index {
        font-size: 1.2rem;
      }
      
      .nav-button {
        padding: 0.7rem 1rem;
        font-size: 1rem;
        border-radius: 10px;
      }
      
      #input-mode .card {
        padding: 50px; /* match Experience Mode card spacing */
      }
      
      #text-editor {
        min-height: 280px;
      }
      
      #monitoring-card p {
        font-size: 1rem;
        margin: 0.7rem 0;
      }
    }

    /* Enhanced styles for Experience Mode Cards (PC Only) */
    @media (min-width: 481px) {
      #experience-mode .card {
        padding: 30px;
      }
      
      /* Adjust button styles */
      #experience-undo-button,
      #skip-sentence-button {
        padding: 20px !important;
        font-size: 1.2rem !important;
      }
      
      /* Adjust target and error sentence fonts */
      #target-sentence,
      #error-sentence {
        font-size: 1.3rem;
        line-height: 1.8;
      }
      
      /* Adjust sentence index style */
      #sentence-index {
        font-size: 1.2rem;
      }
      
      /* Adjust navigation buttons */
      .nav-button {
        padding: 0.7rem 1rem;
        font-size: 1rem;
        border-radius: 10px;
      }
    }

    /* Mobile styles remain unchanged */
    @media (max-width: 480px) {
      .main-content {
        padding: 1rem 0; 
      }
      
      .container {
        width: 94%;
      }
      
      .card {
        padding: 15px;
        margin-bottom: 15px; 
        font-size: 0.9rem; 
      }
      
      .card h3 {
        font-size: 1.1rem;
        margin-bottom: 1rem;
      }

      /* 调整Transcription mode标题大小 */
      #experience-mode h3,
      #input-mode h3 {
        font-size: 1.2rem !important;
        margin-bottom: 1rem;
      }
      
      /* 统一移动端按钮样式 */
      .mode-button,
      #experience-undo-button,
      #skip-sentence-button,
      #next-pair-button,
      #simple-undo-button,
      .clear-button {
        padding: 8px 12px !important;
        font-size: 0.9rem !important;
        border-radius: 6px !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        transition: all 0.2s ease !important;
      }

      /* 特别处理 Next Sentence 按钮样式 */
      #skip-sentence-button {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        min-height: 36px !important;
        text-align: center !important;
        line-height: 1.2 !important;
      }

      #skip-sentence-button:not([style*="background: #6c757d"]) {
        background: #007bff !important;
        color: #fff !important;
        cursor: pointer !important;
      }

      #skip-sentence-button[style*="background: #6c757d"] {
        background: #6c757d !important;
        color: #fff !important;
        cursor: default !important;
        opacity: 0.7 !important;
      }

      /* 调整建议框样式 */
      .suggestions-box-floating {
        max-width: 90vw !important;
        width: auto !important;
        font-size: 1.0rem !important;
      }

      .suggestions-box-floating div {
        padding: 8px 10px !important;
        margin-bottom: 3px !important;
        line-height: 1.5 !important;
      }

      /* 调整导航按钮样式 */
      .nav-button {
        padding: 6px 10px !important;
        font-size: 0.9rem !important;
      }
      
      #text-editor {
        min-height: 200px;
        padding: 1rem;
        font-size: 1rem;
        line-height: 1.5;
      }
      
      #monitoring-card p {
        font-size: 0.9rem;
        margin: 0.5rem 0;
      }
      
      #event-log {
        font-size: 0.85rem;
        max-height: 150px;
      }
      
      #mode-buttons {
        margin-bottom: 15px; 
        gap: 10px;
      }

      /* 调整清除按钮样式 */
      .clear-button {
        padding: 4px 10px !important;
        font-size: 0.85rem !important;
      }

      /* 调整自由输入模式下的 Undo 按钮高度 */
      #simple-undo-button {
        min-height: 36px !important;
      }

      /* 调整错误句子和目标句子的字体大小 */
      #target-sentence {
        font-size: 1.1rem !important;
        line-height: 1.6 !important;
      }

      #error-sentence {
        font-size: 1.2rem !important;
        line-height: 1.6 !important;
      }

      /* 调整建议框的字体大小 */
      .suggestions-box-floating {
        max-width: 90vw !important;
        width: auto !important;
        font-size: 1.0rem !important;
      }

      .suggestions-box-floating div {
        padding: 8px 10px !important;
        margin-bottom: 3px !important;
        line-height: 1.5 !important;
      }
    }

    /* Base styles for navigation buttons */
    .nav-button {
      padding: 0.7rem 1rem;
      border: none;
      border-radius: 8px;
      background: #007bff;
      box-shadow: 0 2px 6px rgba(0,123,255,0.3);
      cursor: pointer;
      color: #ffffff;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    .nav-button:hover {
      background: #0056b3;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,123,255,0.4);
    }

    .nav-button:active {
      transform: translateY(0);
      background: #004494;
      box-shadow: 0 2px 4px rgba(0,123,255,0.2);
    }

    /*******************************************************
     * New: Error sentence text box style
     *******************************************************/
    .editable-sentence-box {
      width: 100%;
      min-height: 150px; 
      padding: 12px 15px;
      background: #f8f9fa;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 1.1rem;
      line-height: 1.6;
      cursor: text;
      transition: all 0.2s ease;
      box-sizing: border-box; 
      
      /* Enhanced text selection disabling for experience mode */
      user-select: none !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-user-drag: none !important;
      pointer-events: auto !important;
    }
    
    .editable-sentence-box:hover {
      background: #f1f3f5;
      border-color: #cbd5e0;
    }
    
    .editable-sentence-box.active {
      border-color: #4299e1;
      box-shadow: 0 0 0 3px rgba(66,153,225,0.15);
    }
    
    .edit-indicator {
      display: inline-block;
      margin-left: 8px;
      font-size: 0.8rem;
      color: #666;
      font-style: italic;
    }

    /*******************************************************
     * New: Cursor feedback at click position
     *******************************************************/
    .cursor-indicator {
      display: inline-block;
      width: 2px;
      height: 1.5em; 
      background-color: #E6B422;
      animation: blink 1s infinite;
      position: absolute;
      z-index: 10;
      pointer-events: none; 
      margin-top: 0; 
      border-radius: 1px; 
      box-shadow: 0 0 3px rgba(230, 180, 34, 0.5);
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    .dragging {
      cursor: text !important;
      user-select: none !important;
      -webkit-user-select: none !important;
    }

    /* Only enable text selection if .dragging is applied with higher priority */
    .editable-sentence-box.dragging {
      cursor: text !important;
      user-select: text !important;
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      -ms-user-select: text !important;
    }

    /* Prevent iOS from text selection on long-press in experience mode */
    @media (hover: none) {
      .editable-sentence-box {
        touch-action: manipulation; 
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
      
      /* 特殊处理自由输入模式 */
      #simple-editor {
        touch-action: manipulation;
        -webkit-user-select: text;
        user-select: text;
      }
      
      /* 短按时恢复选择功能 */
      #simple-editor:focus {
        -webkit-user-select: text;
        user-select: text;
      }
    }

    /* Animation keyframes for long-press feedback */
    @keyframes pulsate {
      0% { transform: scale(0.8); opacity: 0.7; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(1.5); opacity: 0; }
    }

    /* 删除原来的 drawer 样式,添加新的悬浮按钮和菜单样式 */
    #float-menu-button {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      border-radius: 25px;
      background: #007bff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.3s ease;
      z-index: 3000;
    }

    #float-menu-button:hover {
      transform: scale(1.1);
      background: #0056b3;
    }

    #float-menu {
      position: fixed;
      bottom: 80px;
      left: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      padding: 8px;
      display: none;
      flex-direction: column;
      gap: 8px;
      z-index: 3000;
      min-width: 180px;
    }

    #float-menu button {
      padding: 10px 15px;
      border: none;
      border-radius: 8px;
      background: #f8f9fa;
      color: #495057;
      cursor: pointer;
      text-align: left;
      font-size: 0.9rem;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #float-menu button:hover {
      background: #e9ecef;
      transform: translateX(5px);
    }

    #float-menu button i {
      font-size: 1.1rem;
      color: #007bff;
    }

    /* 添加清除按钮样式 */
    .clear-button {
      padding: 4px 12px;
      font-size: 0.9rem;
      border: none;
      border-radius: 4px;
      background: #dc3545;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-left: auto;
    }
    .clear-button:hover {
      background: #c82333;
      transform: translateY(-1px);
    }
    .clear-button:active {
      transform: translateY(0);
    }
    
    /* 调整标题行样式以容纳按钮 */
    .card h3 {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 1.2rem;
    }

    /* 添加禁用状态的样式 */
    #simple-undo-button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    /* 删除其他复杂样式 */
    #simple-undo-button {
      margin-top: 12px;
      width: 100%;
      padding: 20px;
      font-size: 20px;
      border: none;
      border-radius: 6px;
      background: #28a745;
      color: #fff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Header Load -->
  <header id="header-container"></header>

  <!-- Main Content -->
  <div class="main-content">
    <div class="container">
      <!-- Mode Switch Buttons -->
      <div id="mode-buttons">
        <button id="mode-experience" class="mode-button active">Transcription Mode</button>
        <button id="mode-input" class="mode-button">Free-input Mode</button>
      </div>
    </div>

    <!-- Monitoring Area -->
    <div class="container">
      <div class="card" id="monitoring-card">
        <p><strong>Erroneous Sentence:</strong> <span id="error-text">None</span></p>
        <p><strong>Touch Location (character index):</strong> <span id="touch-index">None</span></p>
        <p><strong>Correction Command:</strong> <span id="final-output">None</span></p>
        <p><strong>Recording Status:</strong> <span id="mic-status">🔴 Stopped</span></p>
        <p style="display:none;"><strong>Original Error Sentence:</strong> <span id="original-error-sentence">None</span></p>
        <p style="display:none;"><strong>Speech Input:</strong> <span id="voice-input">None</span></p>
      </div>
    </div>

    <!-- ============ Transcription Mode ============ -->
    <div class="container">
      <div class="card" id="experience-mode">
        <h3>Transcription Mode <i class="fas fa-microphone mic-icon"></i><span class="recording-status-dot"></span></h3>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
            <button class="nav-button" id="prev-sentence" style="visibility:hidden;">←</button>
            <span id="sentence-index">1/5</span>
            <button class="nav-button" id="next-sentence">→</button>
          </div>
          <div>
            <p><strong>Target Sentence:</strong></p>
            <div id="target-sentence" style="user-select:none; margin-bottom: 15px;"></div>
          </div>
          <p><strong>Erroneous Sentence:</strong> <span class="edit-indicator"></span></p>
          <div id="error-sentence" class="editable-sentence-box"></div>
          <div style="display:flex;gap:10px;margin-top:12px;">
            <button id="experience-undo-button" style="
              flex:1;
              padding:20px;
              font-size:20px;
              border:none;
              border-radius:6px;
              background:#28a745;
              color:#fff;
              box-shadow:0 2px 6px rgba(0,0,0,0.2);
              cursor:pointer;
            ">Restore Error Sentence</button>
            <button id="skip-sentence-button" style="
              flex:1;
              padding:20px;
              font-size:20px;
              border:none;
              border-radius:6px;
              background:#6c757d;
              color:#fff;
              box-shadow:0 2px 6px rgba(0,0,0,0.2);
              cursor:pointer;
            ">Next Sentence</button>
          </div>
          <button id="next-pair-button" style="
            width:100%;
            margin-top:10px;
            padding:20px;
            font-size:20px;
            border:none;
            border-radius:6px;
            background:#007bff;
            color:#fff;
            box-shadow:0 2px 6px rgba(0,0,0,0.2);
            cursor:pointer;
            display:none;
          ">Next Sentence</button>
        </div>
      </div>
    </div>

    <!-- ============ Free Input Mode ============ -->
    <div class="container">
      <div class="card" id="input-mode" style="display:none;">
        <h3>
          Free-Input Mode 
          <i class="fas fa-microphone mic-icon"></i>
          <span class="recording-status-dot"></span>
          <button class="clear-button" id="clear-text-button">Clear</button>
        </h3>
        <div id="simple-editor" contenteditable="true" style="
          width: 100%;
          min-height: 401px;
          box-sizing: border-box;
          resize: vertical;      
          overflow: auto;        
          margin: 0 auto;
          background: #fff;      
          border: 2px solid #e2e8f0;
          border-radius: 15px;
          padding: 1.5rem;
          font-size: 1.1rem;
          line-height: 1.6;
          color: #2d3748;
          transition: border-color 0.3s, box-shadow 0.3s;
          white-space: pre-wrap;
          word-wrap: break-word;
          cursor: text;
        ">Try to tap on Wednesday till the mic icon is green, then speak 'on Tuesday'.
Or you can clear the text using the clear button and input your own text.

Hi, how are you? Meet me on Wednesday. us household.</div>
        
        <button id="simple-undo-button" style="
          margin-top:12px;
          width:100%;
          padding:20px;
          font-size:20px;
          border:none;
          border-radius:6px;
          background:#28a745;
          color:#fff;
          box-shadow:0 2px 6px rgba(0,0,0,0.2);
          cursor:pointer;
        ">Undo Last Change</button>
      </div>
    </div>

    <!-- Event Log Area -->
    <div class="container">
      <div class="card" id="event-log-card">
        <h3>Event Log</h3>
        <div id="event-log">No events recorded</div>
      </div>
    </div>
  </div>

  <!-- Footer Load -->
  <footer id="footer-container"></footer>

  <!-- 新的悬浮按钮和菜单 -->
  <button id="float-menu-button">
    <!-- 图标在JS中会替换成svg -->
  </button>
  <div id="float-menu"></div>

  <script>
    /***********************************************
     * ============ A) 通用界面 & 通用代码 ============
     ***********************************************/
    const API_URL = "https://tns.zacchen.win/correct";
    const PUNCTUATION_API_URL = "https://tns.zacchen.win/restore_punctuation";

    // Two Mode Constants
    const MODE_EXPERIENCE = "experience";
    const MODE_INPUT = "input";
    let activeMode = MODE_EXPERIENCE; // default

    // 全局变量
    let disableIME = false;
    let isListening = false;
    let isRecording = false;
    let recognition = null;
    let silenceTimer = null;
    let globalTapIndex = -1;
    let localTapIndex = -1;
    let tapStartIndex = -1;
    let originalSentence = "";
    let lastHighlightedSentence = "";
    let highlightTimeout = null;
    let suggestionsBox = null;
    let suggestionsTimer = null;
    let undoStack = [];
    let isDragging = false;
    let cursorElement = null;
    let cursorTimeout = null;
    let selectedSentence = ""; // 在Transcription模式使用，也会被一些通用函数引用
    let isDraggingAndRecording = false; // 新增变量，用于标记拖动+录音状态
    let useWebkitSpeech = true;
    let maxRecordingTime = 20000; // 最大录音时间，默认10秒
    let currentSentenceInfo = null; // 存储当前句子的详细信息

    // DOM Elements
    const monitoringCard = document.getElementById("monitoring-card");
    const eventLogCard = document.getElementById("event-log-card");
    const errorText = document.getElementById("error-text");
    const originalErrorSpan = document.getElementById("original-error-sentence");
    const touchIndexSpan = document.getElementById("touch-index");
    const voiceInputSpan = document.getElementById("voice-input");
    const micStatusSpan = document.getElementById("mic-status");
    const finalOutputSpan = document.getElementById("final-output");
    const eventLog = document.getElementById("event-log");
    
    // UI按钮引用
    const modeExperienceBtn = document.getElementById("mode-experience");
    const modeInputBtn = document.getElementById("mode-input");

    // 经验模式 & 自由模式 容器
    const modeExperienceContainer = document.getElementById("experience-mode");
    const modeInputContainer = document.getElementById("input-mode");

    /*******************************************************
     * Universal: Toast / Event Log / IME toggle
     *******************************************************/
    function logEvent(message) {
      const p = document.createElement("p");
      const now = new Date().toLocaleString("en-US", {hour12: false});
      p.innerText = `[${now}] ${message}`;
      eventLog.appendChild(p);
    }
    function updateIMEButtonText(enabled) {
      const button = document.getElementById('toggle-ime');
      if (button) {
        button.textContent = enabled ? 'Disable IME' : 'Enable IME';
      }
    }

    /*******************************************************
     * Universal: remove punctuation
     *******************************************************/
    function removePunctuation(str) {
      return str.replace(/[^a-zA-Z0-9'\s]/g, "");
    }

    /*******************************************************
     * Universal: 句子下划线
     *******************************************************/
    function underlineDiffRanges(text, diffRanges) {
      let result = "";
      let currentIndex = 0;
      const validRanges = diffRanges.filter(range => 
        range[0] >= 0 && range[0] < text.length && range[1] > 0 && range[1] <= text.length
      );
      
      validRanges.forEach(function(range) {
        let [start, end] = range;
        end = Math.min(end, text.length);
        
        let diffText = text.substring(start, end);
        let leadingSpaceMatch = diffText.match(/^(\s+)/);
        let leadingSpaceLength = leadingSpaceMatch ? leadingSpaceMatch[0].length : 0;
        
        result += text.substring(currentIndex, start);
        
        if (leadingSpaceLength > 0) {
          result += diffText.substring(0, leadingSpaceLength);
          if (leadingSpaceLength < diffText.length) {
            result += '<span style="border-bottom: 2px solid blue;">'
                      + diffText.substring(leadingSpaceLength) + '</span>';
          }
        } else {
          result += '<span style="border-bottom: 2px solid blue;">' + diffText + '</span>';
        }
        
        currentIndex = end;
      });
      result += text.substring(currentIndex);
      return result;
    }

    /*******************************************************
     * Universal: 通用替换函数
     *******************************************************/
    function replaceFirstOccurrence(fullText, oldPart, newPart) {
      let safe = oldPart.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      let reg = new RegExp(safe, "i");
      return fullText.replace(reg, newPart);
    }

    /*******************************************************
     * Universal: 移除光标
     *******************************************************/
    function removeCursor() {
      if (cursorTimeout) {
        clearTimeout(cursorTimeout);
        cursorTimeout = null;
      }
      if (cursorElement) {
        cursorElement.remove();
        cursorElement = null;
      }
    }

    /*******************************************************
     * Universal: Suggestions Box 移除
     *******************************************************/
    function removeSuggestionsBox() {
      if (suggestionsBox) {
        suggestionsBox.remove();
        suggestionsBox = null;
      }
    }

    /*******************************************************
     * Universal: 同步到后端 /correct API 并处理回传
     *******************************************************/
    function sendToAPI(mergedStr, loc, isExperienceMode) {
      let finalLoc = parseInt(loc, 10) || 0;
      logEvent(`Sending /correct => merged_string:${mergedStr}, touch_location:${finalLoc}, isExpMode:${isExperienceMode}`);
      fetch(API_URL, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ merged_string: mergedStr, touch_location: finalLoc })
      })
      .then(resp => resp.json())
      .then(data => {
        let corrs = data.filtered_corrections || [];
        logEvent("API corrections => " + JSON.stringify(corrs));
        applyFirstSuggestionAndShowBox(corrs, isExperienceMode);
      })
      .catch(err => {
        logEvent("API call error => " + err);
      });
    }

    /*******************************************************
     * Universal: 应用第一个建议并展示额外选项
     * 注意：后面会被Transcription模式 & Free-input模式覆盖使用
     *******************************************************/
    function applyFirstSuggestionAndShowBox(corrections, isExperienceMode) {
      // 这部分在后面会被Transcription模式 & 自由输入模式各自逻辑进行"合并"或"覆盖"
      // 先占位，后面有原始的实现会再次覆盖这个方法
    }

    /*******************************************************
     * Universal: Speech Recognition
     *******************************************************/
    function startRecording(dontProcessResults = false) {
      if (isRecording) {
        console.log("Already recording");
        return;
      }

      // 清除可能存在的停止录音定时器
      if (window.stopRecordingTimer) {
        clearTimeout(window.stopRecordingTimer);
        window.stopRecordingTimer = null;
      }

      // 清空之前的结果
      if (voiceInputSpan) voiceInputSpan.innerText = "";
      
      if (!("SpeechRecognition" in window) && !("webkitSpeechRecognition" in window)) {
        console.warn("Speech recognition not supported in this browser.");
        return;
      }
      
      isRecording = true;
      isListening = true;

      micStatusSpan.innerHTML = "🟢 Recording...";
      micStatusSpan.className = "recording-active";

      // 更新状态指示圆点和麦克风图标
      const dots = document.querySelectorAll('.recording-status-dot');
      const micIcons = document.querySelectorAll('.mic-icon');
      dots.forEach(dot => {
        dot.classList.remove('stopped');
        dot.classList.add('recording');
      });
      micIcons.forEach(icon => {
        icon.classList.add('recording');
      });

      try {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.lang = 'en-US';
        recognition.interimResults = true;
        recognition.continuous = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => {
          isRecording = true;
          isListening = true;
          clearTimeout(silenceTimer);
          silenceTimer = setTimeout(() => {
            if (recognition && isRecording) {
              try { recognition.stop(); } catch (e) { console.error(e); }
            }
          }, 5000);
        };

        recognition.onresult = (event) => {
          clearTimeout(silenceTimer);
          const transcript = Array.from(event.results).map(r => r[0].transcript).join('');
          voiceInputSpan.innerText = transcript;
          finalOutputSpan.innerText = transcript;

          if (!event.results[0].isFinal && recognition) {
            setTimeout(() => {
              try { recognition.stop(); } catch (e) { console.error(e); }
            }, 800);
          }
        };

        recognition.onend = () => {
          clearTimeout(silenceTimer);
          isRecording = false;
          isListening = false;
          micStatusSpan.innerHTML = "🔴 Stopped";
          micStatusSpan.className = "";
          removeCursor();

          // 更新状态指示圆点和麦克风图标
          const dots = document.querySelectorAll('.recording-status-dot');
          const micIcons = document.querySelectorAll('.mic-icon');
          dots.forEach(dot => {
            dot.classList.remove('recording');
          });
          micIcons.forEach(icon => {
            icon.classList.remove('recording');
          });

          if (voiceInputSpan.innerText.trim()) {
            setTimeout(finalizeTapSay, 100);
          } else {
            endTapSay();
          }
        };

        recognition.onerror = (event) => {
          console.error("[Global] recognition error =>", event.error);
          clearTimeout(silenceTimer);
          isRecording = false;
          isListening = false;
          micStatusSpan.innerHTML = "🔴 Error";
          micStatusSpan.className = "";
          removeCursor();

          // 更新状态指示圆点和麦克风图标
          const dots = document.querySelectorAll('.recording-status-dot');
          const micIcons = document.querySelectorAll('.mic-icon');
          dots.forEach(dot => {
            dot.classList.remove('recording');
          });
          micIcons.forEach(icon => {
            icon.classList.remove('recording');
          });

          endTapSay();
        };

        recognition.start();
      } catch (e) {
        isRecording = false;
        isListening = false;
        micStatusSpan.innerHTML = "🔴 Error";
        micStatusSpan.className = "";
        removeCursor();

        // 更新状态指示圆点和麦克风图标
        const dots = document.querySelectorAll('.recording-status-dot');
        const micIcons = document.querySelectorAll('.mic-icon');
        dots.forEach(dot => {
          dot.classList.remove('recording');
        });
        micIcons.forEach(icon => {
          icon.classList.remove('recording');
        });
      }
    }

    function endTapSay() {
      clearTimeout(highlightTimeout);
      clearTimeout(silenceTimer);
      if (recognition) {
        try {
          recognition.onend = null;
          recognition.abort();
        } catch(e) {
          console.error("[Global] endTapSay => error stopping:", e);
        }
        recognition = null;
      }
      isRecording = false;
      isListening = false;
      micStatusSpan.innerHTML = "🔴 Stopped";
      micStatusSpan.className = "";
      removeCursor();
      voiceInputSpan.innerText = "";

      // 更新状态指示圆点和麦克风图标
      const dots = document.querySelectorAll('.recording-status-dot');
      const micIcons = document.querySelectorAll('.mic-icon');
      dots.forEach(dot => {
        dot.classList.remove('recording');
      });
      micIcons.forEach(icon => {
        icon.classList.remove('recording');
      });
    }

    /*******************************************************
     * Universal: finalizeTapSay
     * 当 speech recognition 结束后，把结果发往 API
     *******************************************************/
    function finalizeTapSay() {
      const transcript = (voiceInputSpan.innerText || "").trim();
      if (!transcript) {
        endTapSay();
        return;
      }
      let parted = errorText.innerText.trimEnd();
      parted = parted.replace(/([.!?])(\S)/g, "$1 $2");
      let textNoPunc = removePunctuation(transcript).trimEnd();
      let merged = (parted + " <||> " + textNoPunc).trimEnd();
      finalOutputSpan.innerText = textNoPunc;

      let finalIndex = (activeMode === MODE_INPUT) ? localTapIndex :
                       (tapStartIndex !== -1 ? tapStartIndex : localTapIndex);

      sendToAPI(merged, finalIndex, activeMode === MODE_EXPERIENCE);
      voiceInputSpan.innerText = "";
      lastHighlightedSentence = errorText.innerText;
      tapStartIndex = -1;

      clearTimeout(highlightTimeout);
      highlightTimeout = setTimeout(() => {
        removeCursor();
      }, 3000);
    }

    /***********************************************
     * ============ B) Transcription Mode 代码 ============
     ***********************************************/
    // Transcription模式所需数据
    let currentPairIndex = 0;
    const sentencePairs = [
      {
        target: "Your best bet is to drop him and go after another player.",
        error: "Your best bet is to drop him and go after another.",
        tip: "Tap near the mistake till the mic icon is green, then speak correction. Here's like 'another player'."
      },
      {
        target: "Energy consumption trends in US households are shifting rapidly.",
        error: "Energy consumption trends in us household are shifting rapidly.",
        tip: "Great! It also works on capitalization issues along the way. Here try 'US households'."
      },
      {
        target: "She has been living in Paris for the past five years.",
        error: "She has lived in Paris since five years.",
        tip: "Multiple mistakes can be corrected multiple times"
      },
      {
        target: "The cat sat on the mat. The dog chased the cat. The mouse ran away quickly.",
        error: "The cat sat on the mat. The dog chase the cat. The mouse ran away quickly.",
        tip: "This also works for multi-sentence paragraphs"
      },
      {
        target: "They were discussing the implications of the new policy.",
        error: "They were discuss about the implications of the new policy.",
        tip: "If the first suggestion isn't correct, pick another from the list"
      }
    ];

    /*******************************************************
     * Transcription: 初始化 Experience Mode
     *******************************************************/
    function initializeExperienceMode() {
      updateSentencePair(0);
      attachExpListeners();
    }

    /*******************************************************
     * Transcription: 为错误句子绑定长按、拖动、点击等事件
     *******************************************************/
    function attachExpListeners() {
      const prev = document.getElementById("prev-sentence");
      const next = document.getElementById("next-sentence");
      const skip = document.getElementById("skip-sentence-button");
      const nextPair = document.getElementById("next-pair-button");
      const expUndo = document.getElementById("experience-undo-button");
      const errorSentenceEl = document.getElementById("error-sentence");
      if (!prev || !next || !skip || !nextPair || !expUndo || !errorSentenceEl) return;

      // 取消默认的右键菜单和双击选择
      errorSentenceEl.addEventListener('contextmenu', e => {
        e.preventDefault();
        return false;
      });
      errorSentenceEl.addEventListener('dblclick', e => {
        e.preventDefault();
        return false;
      });
      errorSentenceEl.addEventListener('selectstart', e => {
        if (!isDragging) {
          e.preventDefault();
          return false;
        }
      });

      prev.addEventListener("click", () => {
        if (currentPairIndex > 0) {
          currentPairIndex--;
          updateSentencePair(currentPairIndex);
        }
      });
      next.addEventListener("click", () => {
        if (currentPairIndex < sentencePairs.length - 1) {
          currentPairIndex++;
          updateSentencePair(currentPairIndex);
        }
      });
      skip.addEventListener("click", () => {
        if (currentPairIndex < sentencePairs.length - 1) {
          currentPairIndex++;
          updateSentencePair(currentPairIndex);
          console.log("Skipped current sentence");
        } else {
          console.log("This is the last sentence");
        }
      });
      nextPair.addEventListener("click", () => {
        if (currentPairIndex < sentencePairs.length - 1) {
          currentPairIndex++;
          updateSentencePair(currentPairIndex);
        } else {
          console.log("All sentences completed!");
        }
      });
      expUndo.addEventListener("click", () => {
        const errorSentenceEl = document.getElementById("error-sentence");
        if (!errorSentenceEl) return;
        
        const originalErrorSentence = sentencePairs[currentPairIndex].error;
        errorSentenceEl.innerText = originalErrorSentence;
        
        // 重置选中句
        selectedSentence = "";
        
        // 重置Skip按钮
        const skipBtn = document.getElementById("skip-sentence-button");
        if (skipBtn) {
          skipBtn.textContent = "Next Sentence";
          skipBtn.style.background = "#6c757d";
          skipBtn.style.opacity = "0.7";
          skipBtn.style.pointerEvents = "none";
          skipBtn.style.cursor = "default";
        }
        
        errorSentenceEl.style.background = "";
        errorSentenceEl.style.borderColor = "";
        logEvent("Restored to original error sentence");
      });

      attachTranscriptionLongPress(errorSentenceEl);
    }

    /*******************************************************
     * Transcription: 长按并拖拽选取文字
     *******************************************************/
    function attachTranscriptionLongPress(errorSentenceEl) {
      let pressTimerExp = null;
      let longPressStarted = false;
      let longPressThreshold = 100;
      let isDraggingAndRecording = false;
      let stopRecordingTimer = null;  // 添加一个定时器来延迟停止录音

      // 修改recognition的onresult处理
      if (recognition) {
        recognition.onresult = (event) => {
          clearTimeout(silenceTimer);
          const transcript = Array.from(event.results).map(r => r[0].transcript).join('');
          voiceInputSpan.innerText = transcript;
          finalOutputSpan.innerText = transcript;

          // 如果是拖拽模式，使用当前光标位置更新选中的句子
          if (isDraggingAndRecording) {
            const text = errorSentenceEl.innerText;
            const currentSentence = getCurrentSentenceForTranscription(text, localTapIndex);
            errorText.innerText = currentSentence;
            originalSentence = currentSentence;
            originalErrorSpan.innerText = currentSentence;
            selectedSentence = currentSentence;
          }

          if (!event.results[0].isFinal && recognition) {
            setTimeout(() => {
              try { recognition.stop(); } catch (e) { console.error(e); }
            }, 800);
          }
        };
      }

      errorSentenceEl.addEventListener("mousedown", (e) => {
        // 清除可能存在的停止录音定时器
        if (stopRecordingTimer) {
          clearTimeout(stopRecordingTimer);
          stopRecordingTimer = null;
        }

        if (isDragging) return;
        removeCursor();

        const rect = e.currentTarget.getBoundingClientRect();
        const text = errorSentenceEl.innerText;
        
        // 使用 caretRangeFromPoint 来获取精确的位置
        const x = e.clientX;
        const y = e.clientY;
        if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(x, y);
          if (range) {
            localTapIndex = range.startOffset;
          }
        } else {
          // 回退方案
          const style = window.getComputedStyle(errorSentenceEl);
          const fontSize = parseFloat(style.fontSize);
          const paddingLeft = parseFloat(style.paddingLeft);
          const clickX = e.clientX - rect.left - paddingLeft;
          const averageCharWidth = fontSize * 0.6;
          localTapIndex = Math.round(clickX / averageCharWidth);
        }
        localTapIndex = Math.max(0, Math.min(text.length, localTapIndex));

        // 开始录音（无论是点击还是长按）
        startRecording();

        // 获取当前位置对应的句子信息
        const sentenceInfo = getCurrentSentenceForTranscription(text, localTapIndex);
        errorText.innerText = sentenceInfo.sentence;
        originalSentence = sentenceInfo.sentence;
        originalErrorSpan.innerText = sentenceInfo.sentence;
        selectedSentence = sentenceInfo.sentence;
        
        // 保存句子信息，包括相对位置
        currentSentenceInfo = sentenceInfo;
        // 记录相对位置，用于finalizeTapSay
        tapStartIndex = sentenceInfo.relativePosition;
        console.log("Mouse down - Relative position set to:", sentenceInfo.relativePosition);

        pressTimerExp = setTimeout(() => {
          longPressStarted = true;
          isDraggingAndRecording = true;
          handleExpLongPress();
          showLongPressFeedback(e.clientX, e.clientY);
        }, longPressThreshold);
      });

      errorSentenceEl.addEventListener("mousemove", () => {
        if (pressTimerExp && !longPressStarted) {
          clearTimeout(pressTimerExp);
          pressTimerExp = null;
        }
      });

      errorSentenceEl.addEventListener("mouseup", () => {
        clearTimeout(pressTimerExp);
        pressTimerExp = null;
        longPressStarted = false;
        if (isDraggingAndRecording) {
          isDraggingAndRecording = false;
          isDragging = false;
          errorSentenceEl.classList.remove("dragging");
          
          // 清除之前的定时器（如果存在）
          if (stopRecordingTimer) {
            clearTimeout(stopRecordingTimer);
          }
          
          // 设置3秒后停止录音
          stopRecordingTimer = setTimeout(() => {
            if (recognition) {
              try {
                recognition.stop();
              } catch (ex) {
                console.error("[Transcription] error stopping:", ex);
              }
            }
          }, 3000);
        }
      });

      // touch events
      errorSentenceEl.addEventListener("touchstart", (e) => {
        // 清除可能存在的停止录音定时器
        if (stopRecordingTimer) {
          clearTimeout(stopRecordingTimer);
          stopRecordingTimer = null;
        }

        if (isDragging) return;
        removeCursor();
        
        // 清除可能已有的选择
        const selection = window.getSelection();
        selection.removeAllRanges();

        const touch = e.touches[0];
        const rect = e.currentTarget.getBoundingClientRect();
        const text = errorSentenceEl.innerText;
        
        if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(touch.clientX, touch.clientY);
          if (range) {
            localTapIndex = range.startOffset;
          }
        } else {
          // 回退方案
          const style = window.getComputedStyle(errorSentenceEl);
          const fontSize = parseFloat(style.fontSize);
          const paddingLeft = parseFloat(style.paddingLeft);
          const touchX = touch.clientX - rect.left - paddingLeft;
          const averageCharWidth = fontSize * 0.6;
          localTapIndex = Math.round(touchX / averageCharWidth);
        }
        localTapIndex = Math.max(0, Math.min(text.length, localTapIndex));

        // 开始录音（无论是点击还是长按）
        startRecording();

        // 对于单击，直接使用当前位置选择句子
        const currentSentence = getCurrentSentenceForTranscription(text, localTapIndex);
        errorText.innerText = currentSentence.sentence;
        originalSentence = currentSentence.sentence;
        originalErrorSpan.innerText = currentSentence.sentence;
        selectedSentence = currentSentence.sentence;
        
        // 保存当前句子信息
        currentSentenceInfo = currentSentence;
        // 记录相对位置，用于finalizeTapSay
        tapStartIndex = currentSentence.relativePosition;
        console.log("Touch start - Relative position set to:", currentSentence.relativePosition);

        // 设置标志，防止iOS默认的文本选择
        errorSentenceEl.dataset.touchStarted = "true";
        // 禁用iOS的长按选择行为
        e.preventDefault();

        pressTimerExp = setTimeout(() => {
          if (errorSentenceEl.dataset.touchStarted === "true") {
            longPressStarted = true;
            isDraggingAndRecording = true;
            handleExpLongPress();
            showLongPressFeedback(touch.clientX, touch.clientY);
          }
        }, longPressThreshold);
      });

      errorSentenceEl.addEventListener("touchend", () => {
        if (errorSentenceEl.dataset.touchStarted) {
          delete errorSentenceEl.dataset.touchStarted;
        }
        clearTimeout(pressTimerExp);
        pressTimerExp = null;
        longPressStarted = false;
        if (isDraggingAndRecording) {
          isDraggingAndRecording = false;
          isDragging = false;
          errorSentenceEl.classList.remove("dragging");
          
          // 清除之前的定时器（如果存在）
          if (stopRecordingTimer) {
            clearTimeout(stopRecordingTimer);
          }
          
          // 设置3秒后停止录音
          stopRecordingTimer = setTimeout(() => {
            if (recognition) {
              try {
                recognition.stop();
              } catch (ex) {
                console.error("[Transcription] error stopping:", ex);
              }
            }
          }, 3000);
        }
      });
    }

    /*******************************************************
     * Transcription: 真正执行长按拖拽选词
     *******************************************************/
    function handleExpLongPress() {
      console.log('[Transcription] handleExpLongPress started');
      
      const element = document.getElementById("error-sentence");
      if (!element) {
        console.warn('[Transcription] Error: element not found');
        return;
      }

      isDragging = true;
      element.classList.add("dragging");
      showCursorAtPosition();
      
      // 开始录音，但设置为不自动处理结果
      startRecording(true);

      const handleMouseMove = (e) => {
        if (!isDragging) return;
        e.preventDefault();

        if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(e.clientX, e.clientY);
          if (range && range.startContainer === element.firstChild) {
            localTapIndex = range.startOffset;
          }
        } else {
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          const paddingLeft = parseFloat(style.paddingLeft);
          const moveX = e.clientX - rect.left - paddingLeft;
          const fontSize = parseFloat(style.fontSize);
          const averageCharWidth = fontSize * 0.6;
          localTapIndex = Math.round(moveX / averageCharWidth);
        }
        const text = element.innerText;
        localTapIndex = Math.max(0, Math.min(text.length, localTapIndex));

        // 动态更新选中的句子
        const sentenceInfo = getCurrentSentenceForTranscription(text, localTapIndex);
        console.log("Mouse move - Position info:", {
          localTapIndex: localTapIndex,
          startIndex: sentenceInfo.startIndex,
          relativePosition: sentenceInfo.relativePosition,
          sentence: sentenceInfo.sentence
        });
        
        errorText.innerText = sentenceInfo.sentence;
        originalSentence = sentenceInfo.sentence;
        originalErrorSpan.innerText = sentenceInfo.sentence;
        selectedSentence = sentenceInfo.sentence;
        
        // 更新当前句子信息
        currentSentenceInfo = sentenceInfo;
        // 更新相对位置，用于finalizeTapSay
        tapStartIndex = sentenceInfo.relativePosition;
        
        showCursorAtPosition();
      };

      const handleTouchMove = (e) => {
        if (!isDragging) return;
        e.preventDefault();

        const touch = e.touches[0];
        if (document.caretRangeFromPoint) {
          const range = document.caretRangeFromPoint(touch.clientX, touch.clientY);
          if (range && range.startContainer === element.firstChild) {
            localTapIndex = range.startOffset;
          }
        } else {
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          const paddingLeft = parseFloat(style.paddingLeft);
          const moveX = touch.clientX - rect.left - paddingLeft;
          const fontSize = parseFloat(style.fontSize);
          const averageCharWidth = fontSize * 0.6;
          localTapIndex = Math.round(moveX / averageCharWidth);
        }
        const text = element.innerText;
        localTapIndex = Math.max(0, Math.min(text.length, localTapIndex));

        // 动态更新选中的句子
        const sentenceInfo = getCurrentSentenceForTranscription(text, localTapIndex);
        console.log("Touch move - Position info:", {
          localTapIndex: localTapIndex,
          startIndex: sentenceInfo.startIndex,
          relativePosition: sentenceInfo.relativePosition,
          sentence: sentenceInfo.sentence
        });
        
        errorText.innerText = sentenceInfo.sentence;
        originalSentence = sentenceInfo.sentence;
        originalErrorSpan.innerText = sentenceInfo.sentence;
        selectedSentence = sentenceInfo.sentence;
        
        // 更新当前句子信息
        currentSentenceInfo = sentenceInfo;
        // 更新相对位置，用于finalizeTapSay
        tapStartIndex = sentenceInfo.relativePosition;

        showCursorAtPosition();
      };

      const endDrag = (e) => {
        if (e && e.type === 'touchend') e.preventDefault();
        isDragging = false;
        element.classList.remove("dragging");
        
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", endDrag);
        element.removeEventListener("touchmove", handleTouchMove);
        document.removeEventListener("touchend", endDrag);

        // 如果处于录音状态，现在发送语音内容
        if (isDraggingAndRecording) {
          isDraggingAndRecording = false;
        if (recognition) {
            console.log("Speech recognition ended and processing results");
            recognition.stop();
            
            // 添加简短延迟确保识别结果被处理
        setTimeout(() => {
              if (voiceInputSpan.innerText && voiceInputSpan.innerText.trim()) {
                // 使用最终的句子信息和相对位置
                if (currentSentenceInfo) {
                  const relativePosition = currentSentenceInfo.relativePosition;
                  console.log("End drag - Final position:", {
                    currentSentenceInfo: currentSentenceInfo,
                    relativePosition: relativePosition
                  });
                  
                  // 使用最终录音结果处理纠正，传递相对位置
                  handleRecognitionResult(voiceInputSpan.innerText, relativePosition);
                }
              }
            }, 300);
          }
        }
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", endDrag);
      element.addEventListener("touchmove", handleTouchMove, { passive: false });
      document.addEventListener("touchend", endDrag, { passive: false });
    }

    // 修改getCurrentSentenceForTranscription函数，返回更多信息
    function getCurrentSentenceForTranscription(text, position) {
      const sentenceSeparators = /[.!?]/;
      let startPos = 0;
      let foundSeparator = false;
      
      // 向前搜索句子分隔符
      for (let i = position - 1; i >= 0; i--) {
        if (sentenceSeparators.test(text[i]) &&
          (i + 1 >= text.length || text[i + 1] === ' ' || text[i + 1] === '\n')) {
          startPos = i + 1;
          while (startPos < text.length && (text[startPos] === ' ' || text[startPos] === '\n')) {
            startPos++;
          }
          foundSeparator = true;
          break;
        }
      }
      
      // 如果找不到分隔符，则从文本开始
      if (!foundSeparator) {
        startPos = 0;
        // 跳过开头的空白
        while (startPos < text.length && (text[startPos] === ' ' || text[startPos] === '\n')) {
          startPos++;
        }
      }
      
      let endPos = text.length;
      let foundEndSeparator = false;
      
      // 向后搜索句子分隔符
      for (let i = position; i < text.length; i++) {
        if (sentenceSeparators.test(text[i])) {
          endPos = i + 1;
          foundEndSeparator = true;
          break;
        }
      }
      
      // 如果找不到结束分隔符，则到文本结束
      if (!foundEndSeparator) {
        endPos = text.length;
      }
      
      const sentence = text.substring(startPos, endPos).trim();
      selectedSentence = sentence;
      
      // 确保相对位置计算正确
      const relativePos = position - startPos;
      
      console.log("Sentence detection:", {
        fullText: text,
        position: position,
        startPos: startPos,
        endPos: endPos,
        relativePosition: relativePos,
        sentence: sentence
      });
      
      // 返回包含句子信息的对象
      return {
        sentence: sentence,
        startIndex: startPos,
        endIndex: endPos,
        relativePosition: relativePos
      };
    }

    /*******************************************************
     * Transcription: 在长按时出现的光标
     *******************************************************/
    function showCursorAtPosition() {
      removeCursor();
      const element = document.getElementById("error-sentence");
      if (!element) return;

      const text = element.textContent;
      const textNode = element.firstChild;
      if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return;

      try {
        const style = window.getComputedStyle(element);
        const range = document.createRange();
        range.setStart(textNode, localTapIndex);
        range.collapse(true);

        const rangeRect = range.getBoundingClientRect();
        
        cursorElement = document.createElement("span");
        cursorElement.className = "cursor-indicator";
        cursorElement.style.position = "absolute";

        cursorElement.style.left = (rangeRect.left + window.scrollX) + "px";
        cursorElement.style.top = (rangeRect.top + window.scrollY) + "px";
        cursorElement.style.height = rangeRect.height + "px";

        document.body.appendChild(cursorElement);
        cursorElement.dataset.index = localTapIndex.toString();
        cursorElement.dataset.elementId = "error-sentence";

        if (!isRecording && !isDragging) {
          cursorTimeout = setTimeout(() => { removeCursor(); }, 6000);
        }
        touchIndexSpan.innerText = String(localTapIndex);
      } catch (e) {
        console.error("[Transcription] Error creating cursor:", e);
      }
    }

    function showLongPressFeedback(x, y) {
      // 可以在这里添加长按反馈动画
      console.log("Long-press at:", x, y);
    }

    /*******************************************************
     * Transcription: 检查当前是否完成修正
     *******************************************************/
    function checkCompletion() {
      const targetSentence = document.getElementById("target-sentence");
      const errorSentence = document.getElementById("error-sentence");
      const skipBtn = document.getElementById("skip-sentence-button");
      if (!targetSentence || !errorSentence) return;

      if (errorSentence.innerText.trim() === targetSentence.textContent.trim()) {
        errorSentence.style.background = "#e6ffed";
        errorSentence.style.borderColor = "#34d058";
        setTimeout(() => {
          errorSentence.style.background = "";
          errorSentence.style.borderColor = "";
        }, 2000);

        if (skipBtn && skipBtn.parentNode) {
          const parentElement = skipBtn.parentNode;
          let newElement;
          if (currentPairIndex === sentencePairs.length - 1) {
            newElement = document.createElement("div");
            newElement.id = "skip-sentence-button";
            newElement.textContent = "That's the last one";
            newElement.style.flex = "1";
            newElement.style.padding = "14px";
            newElement.style.fontSize = "16px";
            newElement.style.border = "none";
            newElement.style.borderRadius = "6px";
            newElement.style.background = "#6c757d";
            newElement.style.color = "#fff";
            newElement.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
            newElement.style.cursor = "default";
            newElement.style.opacity = "0.7";
            newElement.style.textAlign = "center";
            newElement.style.userSelect = "none";
            newElement.style.pointerEvents = "none";
          } else {
            newElement = document.createElement("button");
            newElement.id = "skip-sentence-button";
            newElement.textContent = "Next Sentence";
            newElement.style.flex = "1";
            newElement.style.padding = "14px";
            newElement.style.fontSize = "16px";
            newElement.style.border = "none";
            newElement.style.borderRadius = "6px";
            newElement.style.background = "#007bff";
            newElement.style.color = "#fff";
            newElement.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
            newElement.style.cursor = "pointer";

            newElement.addEventListener("click", function nextHandler() {
              currentPairIndex++;
              updateSentencePair(currentPairIndex);
            });
          }
          parentElement.replaceChild(newElement, skipBtn);
        }
      }
    }

    /*******************************************************
     * Transcription: 更新句子对
     *******************************************************/
    function updateSentencePair(index) {
      const targetSentence = document.getElementById("target-sentence");
      const errorSentenceEl = document.getElementById("error-sentence");
      const indexSpan = document.getElementById("sentence-index");
      const prev = document.getElementById("prev-sentence");
      const next = document.getElementById("next-sentence");

      const oldTip = document.querySelector('.tip-box');
      if (oldTip) oldTip.remove();

      const container = document.getElementById("experience-mode");
      container.insertBefore(addTipBox(sentencePairs[index].tip), container.firstChild);

      if (targetSentence) targetSentence.textContent = sentencePairs[index].target;
      if (errorSentenceEl) {
        errorSentenceEl.textContent = sentencePairs[index].error;
        originalSentence = sentencePairs[index].error;
      }

      if (indexSpan) indexSpan.textContent = (index + 1) + "/" + sentencePairs.length;
      if (prev) prev.style.visibility = (index === 0) ? "hidden" : "visible";
      if (next) next.style.visibility = (index === sentencePairs.length - 1) ? "hidden" : "visible";

      const skipBtn = document.getElementById("skip-sentence-button");
      if (skipBtn && skipBtn.parentNode) {
        const parentElement = skipBtn.parentNode;
        const disabledBtn = document.createElement("div");
        disabledBtn.id = "skip-sentence-button";
        disabledBtn.textContent = "Next Sentence";
        disabledBtn.style.flex = "1";
        disabledBtn.style.padding = "14px";
        disabledBtn.style.fontSize = "16px";
        disabledBtn.style.border = "none";
        disabledBtn.style.borderRadius = "6px";
        disabledBtn.style.background = "#6c757d";
        disabledBtn.style.color = "#fff";
        disabledBtn.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
        disabledBtn.style.cursor = "default";
        disabledBtn.style.opacity = "0.7";
        disabledBtn.style.textAlign = "center";
        disabledBtn.style.userSelect = "none";
        disabledBtn.style.pointerEvents = "none";
        parentElement.replaceChild(disabledBtn, skipBtn);
      }
    }

    function addTipBox(tip) {
      const tipBox = document.createElement('div');
      tipBox.className = 'tip-box';
      tipBox.innerHTML = `
        <div class="tip-content">
          ${tip}
        </div>
      `;
      return tipBox;
    }

    /*******************************************************
     * 覆盖: applyFirstSuggestionAndShowBox (Transcription)
     *******************************************************/
    const originalApply = applyFirstSuggestionAndShowBox;
    applyFirstSuggestionAndShowBox = function(corrections, isExperienceMode) {
      if (!corrections.length) return;
      
      if (isExperienceMode) {
        // ==========【原始的 Transcription 逻辑】==========
        if (!document.getElementById("error-sentence")) return;
        
        let candidateObj = corrections[0];
        let candidate = candidateObj.corrected_text.trimEnd();
        let diffRanges = candidateObj.diff_ranges;
        
        const errorSentenceEl = document.getElementById("error-sentence");
        let entireText = errorSentenceEl.innerText;
        
        // 将原先选中的句子替换为 candidate
        let updatedText = replaceFirstOccurrence(entireText, selectedSentence, candidate);
        errorSentenceEl.innerText = updatedText;
        selectedSentence = candidate;

        // 如果有 diffRanges 就加下划线
        if (diffRanges && diffRanges.length > 0) {
          let newSentenceIndex = updatedText.indexOf(candidate);
          if (newSentenceIndex >= 0) {
            let newHtml = updatedText.substring(0, newSentenceIndex);
            newHtml += underlineDiffRanges(candidate, diffRanges);
            newHtml += updatedText.substring(newSentenceIndex + candidate.length);
            errorSentenceEl.innerHTML = newHtml;
            
            setTimeout(() => {
              errorSentenceEl.innerText = errorSentenceEl.innerText;
            }, 2000);
          }
        }

        // 如果有多个修正建议，则展示建议列表
        if (corrections.length > 1) {
          let rect = errorSentenceEl.getBoundingClientRect();
          suggestionsBox = createSuggestionBox(rect, corrections, true);
          if (suggestionsBox) {
            document.body.appendChild(suggestionsBox);
            clearTimeout(suggestionsTimer);
            suggestionsTimer = setTimeout(removeSuggestionsBox, 3000);
          }
        }
        checkCompletion();
      } else {
        // 如果不是Experience模式，就调用后面 free-input 的逻辑
        originalApply(corrections, isExperienceMode);
      }
    };

    /*******************************************************
     * Transcription: 创建一个建议box
     *******************************************************/
    function createSuggestionBox(rect, corrections, isExpMode) {
      let box = document.createElement("div");
      box.className = "suggestions-box-floating";
      
      if (isExpMode) {
        // Transcription模式的定位逻辑保持不变
        const errorSentenceEl = document.getElementById("error-sentence");
        if (errorSentenceEl) {
          const text = errorSentenceEl.innerText;
          const firstSuggestion = corrections[0].corrected_text.trimEnd();
          const range = document.createRange();
          const textNode = errorSentenceEl.firstChild;
          
          if (textNode) {
            const startIndex = text.indexOf(firstSuggestion);
            if (startIndex !== -1) {
              try {
                range.setStart(textNode, startIndex);
                range.setEnd(textNode, startIndex + 1);
                const selectedRect = range.getBoundingClientRect();
                const boxLeft = selectedRect.left + window.scrollX;
                const boxTop = selectedRect.bottom + window.scrollY + 5;

                box.style.left = boxLeft + "px";
                box.style.top = boxTop + "px";
                box.style.minWidth = selectedRect.width + "px";
                box.style.width = "auto";
                box.style.maxWidth = "500px";
              } catch (e) {
                console.error('[SuggestionBox] Error setting range:', e);
              }
            }
          }
        }
      } else {
        // 自由输入模式的定位逻辑
        const simpleEditor = document.getElementById('simple-editor');
        if (simpleEditor && originalSentence) {
          const text = simpleEditor.textContent;
          const sentenceStart = text.indexOf(originalSentence);
          
          if (sentenceStart !== -1) {
            try {
              // 创建一个范围来获取选中句子的位置
              const range = document.createRange();
              const textNode = simpleEditor.firstChild;
              range.setStart(textNode, sentenceStart);
              range.setEnd(textNode, sentenceStart + originalSentence.length);
              
              // 获取选中文本的位置信息
              const sentenceRect = range.getBoundingClientRect();
              
              // 设置建议框的样式和位置
              box.style.position = 'absolute';
              box.style.top = (sentenceRect.bottom + window.scrollY + 5) + 'px';  // 在句子下方5px处
              box.style.left = (sentenceRect.left + window.scrollX) + 'px';
              box.style.width = 'auto';
              box.style.maxWidth = simpleEditor.offsetWidth - 40 + 'px'; // 留出一些边距
              box.style.zIndex = '1000';
              
              // 直接将建议框添加到文档中
              document.body.appendChild(box);
            } catch (e) {
              console.error('[SuggestionBox] Error calculating position:', e);
            }
          }
        }
      }

      for (let i = 1; i < corrections.length; i++) {
        let candidateObj = corrections[i];
        let candidate = candidateObj.corrected_text.trimEnd();
        let diffRanges = candidateObj.diff_ranges;

        let div = document.createElement("div");
        if (diffRanges && diffRanges.length > 0) {
          div.innerHTML = underlineDiffRanges(candidate, diffRanges);
        } else {
          div.innerText = candidate;
        }

        div.onclick = (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          if (isExpMode) {
            // Transcription模式的点击处理保持不变
          const errorSentenceEl = document.getElementById("error-sentence");
          if (!errorSentenceEl) return;

          let entireText = errorSentenceEl.innerText;
          let updated = replaceFirstOccurrence(entireText, selectedSentence, candidate);
          errorSentenceEl.innerText = updated;
          selectedSentence = candidate;

          if (diffRanges && diffRanges.length > 0) {
            let newSentenceIndex = updated.indexOf(candidate);
            if (newSentenceIndex >= 0) {
              let newHtml = updated.substring(0, newSentenceIndex);
              newHtml += underlineDiffRanges(candidate, diffRanges);
              newHtml += updated.substring(newSentenceIndex + candidate.length);
              errorSentenceEl.innerHTML = newHtml;
              
              setTimeout(() => {
                errorSentenceEl.innerText = errorSentenceEl.innerText;
              }, 2000);
            }
          }
          checkCompletion();
          } else {
            // 自由输入模式的点击处理
            window.replaceSentenceInSimpleEditor(originalSentence, candidate);
            originalSentence = candidate;
          }
          removeSuggestionsBox();
        };
        box.appendChild(div);
      }
      return box;
    }


    /*******************************************************
     * ============ C) 自由输入模式 代码 ============
     ***********************************************/

    /*******************************************************
     * Free Input: 为简单文本区添加事件
     *******************************************************/
    function attachFreeInputListeners() {
      const editor = document.getElementById('simple-editor');
      if (!editor) return;
      
      // 初始化时将初始内容放入撤销栈
      simpleUndoStack = [editor.innerHTML];
      updateUndoButtonState();
      
      let pressTimer = null;
      let lastContent = editor.innerHTML;
      let touchStartX = 0;
      let touchStartY = 0;
      let isTouchMoved = false;
      let touchStartTime = 0;
      
      // PC端鼠标事件处理
      editor.addEventListener('mousedown', (e) => {
        if (activeMode !== MODE_INPUT) return;
        handlePressStart(e.clientX, e.clientY, false);
      });

      document.addEventListener('mouseup', () => {
        handlePressEnd();
      });

      // 移动端触摸事件处理
      editor.addEventListener('touchstart', (e) => {
        if (activeMode !== MODE_INPUT) return;
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        touchStartTime = Date.now();
        isTouchMoved = false;
        
        // 长按时先阻止默认行为，避免iOS的文本选择功能
        if (e.touches.length === 1) {
          // 不是滚动操作时才阻止默认行为
          const isScrollArea = (touch.clientY > (editor.offsetTop + editor.offsetHeight - 40));
          if (!isScrollArea) {
            e.preventDefault();
          }
        }
        
        handlePressStart(touch.clientX, touch.clientY, true);
      });

      editor.addEventListener('touchmove', (e) => {
        if (pressTimer) {
          const touch = e.touches[0];
          const moveX = Math.abs(touch.clientX - touchStartX);
          const moveY = Math.abs(touch.clientY - touchStartY);
          if (moveX > 10 || moveY > 10) {
            isTouchMoved = true;
            handlePressEnd();
          }
        }
      });

      editor.addEventListener('touchend', (e) => {
        if (!isTouchMoved) {
          const touchEndTime = Date.now();
          const touchDuration = touchEndTime - touchStartTime;
          
          if (touchDuration < 500) {
            // 短按，处理选择
            const touch = e.changedTouches[0];
            const range = document.caretRangeFromPoint(touch.clientX, touch.clientY);
            if (range) {
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }
          handlePressEnd();
        }
      });

      // 统一的按压开始处理函数
      function handlePressStart(clientX, clientY, isTouch) {
        editor.focus();
        
        // 清除可能存在的停止录音定时器
        if (window.stopRecordingTimer) {
          clearTimeout(window.stopRecordingTimer);
          window.stopRecordingTimer = null;
        }
        
        pressTimer = setTimeout(() => {
          // 清除可能已有的选择
          const selection = window.getSelection();
          selection.removeAllRanges();
          
          // 标记为拖动+录音状态
          isDraggingAndRecording = true;
          
          // 获取当前句子
          const range = document.caretRangeFromPoint(clientX, clientY);
          if (range) {
            const sentenceInfo = getFreeInputSentence(editor.textContent, range.startOffset);
            errorText.innerText = sentenceInfo.sentence;
            originalSentence = sentenceInfo.sentence;
            originalErrorSpan.innerText = sentenceInfo.sentence;
            localTapIndex = range.startOffset;
            
            // 开始录音，但不自动处理结果
            startRecording(true);
          }
        }, isTouch ? 700 : 500); // 触摸设备使用稍长的长按时间
      }
      
      // 统一的按压结束处理函数
      function handlePressEnd() {
        if (pressTimer) {
          clearTimeout(pressTimer);
          pressTimer = null;
        }
        
        // 如果处于拖动+录音状态，只需标记为结束，但不立即停止录音
        if (isDraggingAndRecording) {
          isDraggingAndRecording = false;
          
          // 清除之前可能存在的停止录音定时器
          if (window.stopRecordingTimer) {
            clearTimeout(window.stopRecordingTimer);
          }
          
          // 设置3秒后停止录音
          window.stopRecordingTimer = setTimeout(() => {
            if (recognition) {
              console.log("Free input: 3秒后自动停止录音");
              try {
                recognition.stop();
                // onend事件处理程序会调用finalizeTapSay
              } catch (ex) {
                console.error("Error stopping recognition:", ex);
              }
            }
          }, 3000);
        }
      }
      
      // 监听input变化推入undo栈
      editor.addEventListener('input', function() {
        const currentContent = this.innerHTML;
        // 只有当内容真的改变时才添加到撤销栈
        if (currentContent !== lastContent) {
          simpleUndoStack.push(currentContent);
        if (simpleUndoStack.length > 20) {
          simpleUndoStack.shift();
          }
          lastContent = currentContent;
          updateUndoButtonState();
        }
      });
      
      // 文件拖拽
      editor.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.style.background = "#fafafa";
      });
      
      editor.addEventListener('dragleave', function() {
        this.style.background = "#fff";
      });
      
      editor.addEventListener('drop', function(e) {
        e.preventDefault();
        this.style.background = "#fff";

        const files = e.dataTransfer.files;
        if (files.length > 0) {
          const file = files[0];
          const fname = file.name.toLowerCase();
          if (fname.endsWith(".txt") || fname.endsWith(".doc")) {
            let reader = new FileReader();
            reader.onload = (evt) => {
              this.textContent = evt.target.result;
              simpleUndoStack.push(this.innerHTML);
              lastContent = this.innerHTML;
              updateUndoButtonState();
              logEvent("File loaded: " + file.name);
            };
            reader.readAsText(file, "UTF-8");
          } else {
            console.warn("Only .txt or .doc files are supported");
          }
        }
      });

      // 添加自由输入模式的移动监听器
      editor.addEventListener('mousemove', (e) => {
        if (isDraggingAndRecording) {
          const range = document.caretRangeFromPoint(e.clientX, e.clientY);
          if (range) {
            const sentenceInfo = getFreeInputSentence(editor.textContent, range.startOffset);
            errorText.innerText = sentenceInfo.sentence;
            originalSentence = sentenceInfo.sentence;
            originalErrorSpan.innerText = sentenceInfo.sentence;
          }
        }
      });

      editor.addEventListener('touchmove', (e) => {
        if (isDraggingAndRecording) {
          const touch = e.touches[0];
          const range = document.caretRangeFromPoint(touch.clientX, touch.clientY);
          if (range) {
            const sentenceInfo = getFreeInputSentence(editor.textContent, range.startOffset);
            errorText.innerText = sentenceInfo.sentence;
            originalSentence = sentenceInfo.sentence;
            originalErrorSpan.innerText = sentenceInfo.sentence;
          }
        } else if (pressTimer) {
          const touch = e.touches[0];
          const moveX = Math.abs(touch.clientX - touchStartX);
          const moveY = Math.abs(touch.clientY - touchStartY);
          if (moveX > 10 || moveY > 10) {
            isTouchMoved = true;
            handlePressEnd();
          }
        }
      });
    }

    // 专门获取句子
    function getFreeInputSentence(text, position) {
      const sentenceSeparators = /[.!?]/;
      let startPos = 0;
      for (let i = position - 1; i >= 0; i--) {
        if (sentenceSeparators.test(text[i]) &&
          (i + 1 >= text.length || text[i + 1] === ' ' || text[i + 1] === '\n')) {
          startPos = i + 1;
          while (startPos < text.length && (text[startPos] === ' ' || text[startPos] === '\n')) {
            startPos++;
          }
          break;
        }
      }
      
      let endPos = text.length;
      for (let i = position; i < text.length; i++) {
        if (sentenceSeparators.test(text[i])) {
          endPos = i + 1;
          break;
        }
      }
      return { sentence: text.substring(startPos, endPos).trim(), startPos: startPos, endPos: endPos };
    }

    // Free-input专用的undo栈
    let simpleUndoStack = [''];
    const simpleUndoButton = document.getElementById('simple-undo-button');

    // 更新按钮状态的函数
    function updateUndoButtonState() {
      const simpleUndoButton = document.getElementById('simple-undo-button');
      if (simpleUndoButton) {
        if (simpleUndoStack.length <= 1) {
          simpleUndoButton.disabled = true;
          simpleUndoButton.style.background = '#6c757d';
          simpleUndoButton.style.cursor = 'not-allowed';
        } else {
          simpleUndoButton.disabled = false;
          simpleUndoButton.style.background = '#28a745';
          simpleUndoButton.style.cursor = 'pointer';
        }
      }
    }

    if (simpleUndoButton) {
      // 初始状态
      updateUndoButtonState();
      
      simpleUndoButton.addEventListener('click', function() {
        const simpleEditor = document.getElementById('simple-editor');
        if (simpleEditor && simpleUndoStack.length > 1) {
          // 移除当前状态
          simpleUndoStack.pop();
          // 恢复到上一个状态
          const previousContent = simpleUndoStack[simpleUndoStack.length - 1];
          simpleEditor.innerHTML = previousContent;
          
          // 将光标移到末尾
          const range = document.createRange();
          const selection = window.getSelection();
          range.selectNodeContents(simpleEditor);
          range.collapse(false);
          selection.removeAllRanges();
          selection.addRange(range);
          
          simpleEditor.focus();
          updateUndoButtonState();
        }
      });
    }

    // 用来替换句子(自由模式)
    window.replaceSentenceInSimpleEditor = function(originalText, newText) {
      const simpleEditor = document.getElementById('simple-editor');
      if (!simpleEditor) return false;
      
      const currentContent = simpleEditor.innerHTML;
      const updatedContent = currentContent.replace(originalText, newText);
      
      if (currentContent !== updatedContent) {
        simpleUndoStack.push(updatedContent);
        simpleEditor.innerHTML = updatedContent;
        updateUndoButtonState();
      return true;
      }
      return false;
    };

    /*******************************************************
     * 覆盖: applyFirstSuggestionAndShowBox (Free Input)
     *******************************************************/
    const originalApplyGlobal = applyFirstSuggestionAndShowBox;
    applyFirstSuggestionAndShowBox = function(corrections, isExperienceMode) {
      if (!corrections.length) return;
      
      if (isExperienceMode) {
        // 如果是Transcription模式，调用之前覆盖的版本
        originalApplyGlobal(corrections, isExperienceMode);
      } else {
        // ==========【Free Input模式逻辑】==========
        const simpleEditor = document.getElementById('simple-editor');
        if (!simpleEditor) return;
        
        let candidateObj = corrections[0];
        let candidate = candidateObj.corrected_text.trimEnd();
        let diffRanges = candidateObj.diff_ranges;
        
        if (window.replaceSentenceInSimpleEditor(originalSentence, candidate)) {
          originalSentence = candidate;
          simpleEditor.focus();

          if (corrections.length > 1) {
            suggestionsBox = createSuggestionBox(null, corrections, false);
            if (suggestionsBox) {
              document.body.appendChild(suggestionsBox);
              clearTimeout(suggestionsTimer);
              suggestionsTimer = setTimeout(removeSuggestionsBox, 3000);
            }
          }
        }
      }
    };

    /*******************************************************
     * Transcription: 创建一个建议box
     *******************************************************/
    function createSuggestionBox(rect, corrections, isExpMode) {
      let box = document.createElement("div");
      box.className = "suggestions-box-floating";
      
      if (isExpMode) {
        // Transcription模式的定位逻辑保持不变
        const errorSentenceEl = document.getElementById("error-sentence");
        if (errorSentenceEl) {
          const text = errorSentenceEl.innerText;
          const firstSuggestion = corrections[0].corrected_text.trimEnd();
          const range = document.createRange();
          const textNode = errorSentenceEl.firstChild;
          
          if (textNode) {
            const startIndex = text.indexOf(firstSuggestion);
            if (startIndex !== -1) {
              try {
                range.setStart(textNode, startIndex);
                range.setEnd(textNode, startIndex + 1);
                const selectedRect = range.getBoundingClientRect();
                const boxLeft = selectedRect.left + window.scrollX;
                const boxTop = selectedRect.bottom + window.scrollY + 5;

                box.style.left = boxLeft + "px";
                box.style.top = boxTop + "px";
                box.style.minWidth = selectedRect.width + "px";
                box.style.width = "auto";
                box.style.maxWidth = "500px";
              } catch (e) {
                console.error('[SuggestionBox] Error setting range:', e);
              }
            }
          }
        }
      } else {
        // 自由输入模式的定位逻辑
        const simpleEditor = document.getElementById('simple-editor');
        if (simpleEditor && originalSentence) {
          const text = simpleEditor.textContent;
          const sentenceStart = text.indexOf(originalSentence);
          
          if (sentenceStart !== -1) {
            try {
              // 创建一个范围来获取选中句子的位置
              const range = document.createRange();
              const textNode = simpleEditor.firstChild;
              range.setStart(textNode, sentenceStart);
              range.setEnd(textNode, sentenceStart + originalSentence.length);
              
              // 获取选中文本的位置信息
              const sentenceRect = range.getBoundingClientRect();
              
              // 设置建议框的样式和位置
              box.style.position = 'absolute';
              box.style.top = (sentenceRect.bottom + window.scrollY + 5) + 'px';  // 在句子下方5px处
              box.style.left = (sentenceRect.left + window.scrollX) + 'px';
              box.style.width = 'auto';
              box.style.maxWidth = simpleEditor.offsetWidth - 40 + 'px'; // 留出一些边距
              box.style.zIndex = '1000';
              
              // 直接将建议框添加到文档中
              document.body.appendChild(box);
            } catch (e) {
              console.error('[SuggestionBox] Error calculating position:', e);
            }
          }
        }
      }

      for (let i = 1; i < corrections.length; i++) {
        let candidateObj = corrections[i];
        let candidate = candidateObj.corrected_text.trimEnd();
        let diffRanges = candidateObj.diff_ranges;

        let div = document.createElement("div");
        if (diffRanges && diffRanges.length > 0) {
          div.innerHTML = underlineDiffRanges(candidate, diffRanges);
        } else {
          div.innerText = candidate;
        }

        div.onclick = (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          if (isExpMode) {
            // Transcription模式的点击处理保持不变
            const errorSentenceEl = document.getElementById("error-sentence");
            if (!errorSentenceEl) return;

            let entireText = errorSentenceEl.innerText;
            let updated = replaceFirstOccurrence(entireText, selectedSentence, candidate);
            errorSentenceEl.innerText = updated;
            selectedSentence = candidate;

            if (diffRanges && diffRanges.length > 0) {
              let newSentenceIndex = updated.indexOf(candidate);
              if (newSentenceIndex >= 0) {
                let newHtml = updated.substring(0, newSentenceIndex);
                newHtml += underlineDiffRanges(candidate, diffRanges);
                newHtml += updated.substring(newSentenceIndex + candidate.length);
                errorSentenceEl.innerHTML = newHtml;
                
                setTimeout(() => {
                  errorSentenceEl.innerText = errorSentenceEl.innerText;
                }, 2000);
              }
            }
            checkCompletion();
          } else {
            // 自由输入模式的点击处理
            window.replaceSentenceInSimpleEditor(originalSentence, candidate);
            originalSentence = candidate;
          }
          removeSuggestionsBox();
        };
        box.appendChild(div);
      }
      return box;
    }


    /*******************************************************
     * ============ D) window.onload & 主入口 ============
     *******************************************************/
    window.onload = async function() {
      // 尝试加载header/footer
      try {
        const headerRes = await fetch("header.html");
        const headerHtml = await headerRes.text();
        document.getElementById("header-container").innerHTML = headerHtml;

        const footerRes = await fetch("footer.html");
        const footerHtml = await footerRes.text();
        document.getElementById("footer-container").innerHTML = footerHtml;
      } catch(e) {
        console.warn("Failed to load header/footer:", e);
      }

      // 默认隐藏 monitoring 和 event log
      monitoringCard.style.display = "none";
      eventLogCard.style.display = "none";

      // 检查麦克风权限
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({audio: true})
        .catch(err => {
          console.warn("Mic permission error:", err);
        });
      }

      // 初始化模式
      modeExperienceContainer.style.display = "block";
      modeInputContainer.style.display = "none";
      modeExperienceBtn.classList.add("active");
      modeInputBtn.classList.remove("active");
      activeMode = MODE_EXPERIENCE;

      // 初始化Transcription模式
      initializeExperienceMode();

      // 为Free Input mode添加提示框
      const inputModeContainer = document.getElementById("input-mode");
      if (inputModeContainer) {
        inputModeContainer.insertBefore(
          addTipBox("Tap on the place you want to edit, till the mic icon is green, then speak correction. "),
          inputModeContainer.firstChild
        );
      }

      // 绑定Free Input监听
      attachFreeInputListeners();

      // 取消选中文本(Transcription模式时)
      document.addEventListener('mouseup', () => {
        if (activeMode === MODE_EXPERIENCE && !isDragging) {
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const errorSentenceEl = document.getElementById("error-sentence");
            if (errorSentenceEl && !errorSentenceEl.classList.contains('dragging')) {
              selection.removeAllRanges();
            }
          }
        }
      });
      document.addEventListener('selectionchange', () => {
        if (activeMode === MODE_EXPERIENCE && !isDragging) {
          const errorSentenceEl = document.getElementById("error-sentence");
          if (errorSentenceEl && !errorSentenceEl.classList.contains('dragging')) {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
              const range = selection.getRangeAt(0);
              if (errorSentenceEl.contains(range.commonAncestorContainer)) {
                selection.removeAllRanges();
              }
            }
          }
        }
      });

      // 监听模式切换
      modeExperienceBtn.addEventListener("click", function() {
        if (!this.classList.contains("active")) {
          this.classList.add("active");
          modeInputBtn.classList.remove("active");
          modeExperienceContainer.style.display = "block";
          modeInputContainer.style.display = "none";
          activeMode = MODE_EXPERIENCE;
        }
      });
      modeInputBtn.addEventListener("click", function() {
        if (!this.classList.contains("active")) {
          this.classList.add("active");
          modeExperienceBtn.classList.remove("active");
          modeExperienceContainer.style.display = "none";
          modeInputContainer.style.display = "block";
          activeMode = MODE_INPUT;
        }
      });

      // 打Log
      logEvent("Application initialized - Monitoring and logs are hidden by default");


      /*******************************************************
       * 浮动菜单相关逻辑
       *******************************************************/
      const menuButton = document.getElementById('float-menu-button');
      const menu = document.getElementById('float-menu');
      menu.innerHTML = `
        <button id="float-monitoring">
          Show Monitoring
        </button>
        <button id="float-log">
          Show Event Log
        </button>
      `;

      let menuVisible = false;
      menuButton.innerHTML = `
        <svg viewBox="0 0 24 24" width="24" height="24">
          <path fill="white" d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
      `;

      menuButton.addEventListener('click', (e) => {
        e.stopPropagation();
        menuVisible = !menuVisible;
        menu.style.display = menuVisible ? 'flex' : 'none';
      });
      document.addEventListener('click', (e) => {
        if (!menu.contains(e.target) && !menuButton.contains(e.target)) {
          menuVisible = false;
          menu.style.display = 'none';
        }
      });

      const floatMonitoringBtn = document.getElementById('float-monitoring');
      const floatLogBtn = document.getElementById('float-log');
      const floatImeBtn = document.getElementById('float-ime');

      if (floatMonitoringBtn) {
        floatMonitoringBtn.addEventListener('click', () => {
          const isHidden = (monitoringCard.style.display === 'none');
          monitoringCard.style.display = isHidden ? 'block' : 'none';
          floatMonitoringBtn.textContent = isHidden ? 'Hide Monitoring' : 'Show Monitoring';
        });
      }
      if (floatLogBtn) {
        floatLogBtn.addEventListener('click', () => {
          const isHidden = (eventLogCard.style.display === 'none');
          eventLogCard.style.display = isHidden ? 'block' : 'none';
          floatLogBtn.textContent = isHidden ? 'Hide Event Log' : 'Show Event Log';
        });
      }
      if (floatImeBtn) {
        floatImeBtn.addEventListener('click', () => {
          disableIME = !disableIME;
          const editor = document.getElementById('text-editor');
          if (editor) {
            if (disableIME) editor.classList.add('disable-ime');
            else editor.classList.remove('disable-ime');
          }
          floatImeBtn.innerHTML = `
            <i class="fas fa-keyboard"></i>
            IME Shortcuts: ${disableIME ? 'OFF' : 'ON'}
          `;
        });
      }

      // 添加清除按钮功能
      const clearButton = document.getElementById('clear-text-button');
      if (clearButton) {
        clearButton.addEventListener('click', function() {
          const simpleEditor = document.getElementById('simple-editor');
          if (simpleEditor) {
            const currentContent = simpleEditor.innerHTML;
            if (currentContent.trim() !== '') {
              simpleUndoStack.push('');
              simpleEditor.innerHTML = '';
              simpleEditor.focus();
              updateUndoButtonState();
            }
          }
        });
      }
    };

    // 添加录音状态反馈函数
    function showRecordingFeedback(isRecording) {
      // 更新麦克风状态文本
      if (micStatusSpan) {
        micStatusSpan.innerHTML = isRecording ? "🟢 Recording..." : "🔴 Stopped";
        micStatusSpan.className = isRecording ? "recording-active" : "";
      }
      
      // 更新状态指示圆点和麦克风图标
      const dots = document.querySelectorAll('.recording-status-dot');
      const micIcons = document.querySelectorAll('.mic-icon');
      
      if (isRecording) {
        dots.forEach(dot => {
          dot.classList.remove('stopped');
          dot.classList.add('recording');
        });
        micIcons.forEach(icon => {
          icon.classList.add('recording');
        });
      } else {
        dots.forEach(dot => {
          dot.classList.remove('recording');
          dot.classList.add('stopped');
        });
        micIcons.forEach(icon => {
          icon.classList.remove('recording');
        });
        
        // 移除光标
        removeCursor();
      }
    }

    // 停止录音的函数
    function stopRecording() {
      if (recognition) {
        try { 
          recognition.onend = null; // 防止onend触发finalizeTapSay
          recognition.stop(); 
        } catch(e) { 
          console.error(e); 
        }
      }
      
      // 清理状态
      isRecording = false;
      isListening = false;
      
      // 更新UI
      if (micStatusSpan) {
        micStatusSpan.innerHTML = "🔴 Stopped";
        micStatusSpan.className = "";
      }
      
      // 更新麦克风图标状态
      const dots = document.querySelectorAll('.recording-status-dot');
      const micIcons = document.querySelectorAll('.mic-icon');
      dots.forEach(dot => {
        dot.classList.remove('recording');
      });
      micIcons.forEach(icon => {
        icon.classList.remove('recording');
      });
    }

    // Handle speech recognition results, add relative position parameter
    function handleRecognitionResult(transcript, relativePosition = 0) {
      if (!transcript || !transcript.trim()) return;
      
      // Convert speech recognition results to lowercase
      const lowerCaseTranscript = transcript.toLowerCase();
      
      console.log("Processing voice command, relative position:", relativePosition);
      console.log("Original transcript:", transcript);
      console.log("Lowercase transcript:", lowerCaseTranscript);
      
      // Process voice commands
      try {
        // Check if there is an AI message processing function
        if (typeof proceedWithAI === 'function') {
          // Pass relative position information to AI processing function
          console.log("Using proceedWithAI, relative position:", relativePosition);
          proceedWithAI(originalSentence, lowerCaseTranscript, relativePosition);
        } else {
          // Apply simple replacement directly
          if (activeMode === MODE_EXPERIENCE) {
            // In Transcription mode, use the currently selected sentence and voice input
            console.log("Using applyCorrection, relative position:", relativePosition);
            applyCorrection(selectedSentence, lowerCaseTranscript, relativePosition);
          } else if (activeMode === MODE_INPUT) {
            // Free input mode should use finalizeTapSay which will call API
            voiceInputSpan.innerText = transcript;
            errorText.innerText = originalSentence;
            finalOutputSpan.innerText = transcript;
            // Let the API handle the correction via finalizeTapSay (called by recognition.onend)
          }
        }
      } catch (error) {
        console.error("Error processing voice command:", error);
      }
    }

    // Add applyCorrection function, adapt to new relative position parameter
    function applyCorrection(sentence, transcript, relativePosition = 0) {
      console.log("Applying correction, original:", sentence, "correction:", transcript, "relative position:", relativePosition);
      
      // Build merged string
      const mergedStr = sentence + " || " + transcript;
      
      // Use the incoming relative position directly, no need to add startIndex
      // Because the API needs relative position rather than absolute position
      let finalPosition = relativePosition;
      
      console.log("Sending to API with position:", finalPosition);
      
      // Call API
      sendToAPI(mergedStr, finalPosition, activeMode === MODE_EXPERIENCE);
    }
  </script>
</body>
</html>