<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- 在移动端正确缩放 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tap&Say Text Editor (Simplified)</title>
  <style>
    /* ========== 全局基础样式 ========== */
    html, body {
      margin: 0; padding: 0;
      width: 100%; max-width: 100%;
      box-sizing: border-box;
      overflow-x: hidden;
      font-family: Arial, sans-serif;
    }
    *, *::before, *::after {
      box-sizing: inherit;
    }
    body {
      display: flex; flex-direction: column;
      min-height: 100vh; background-color: #f4f4f4;
    }
    /* header/footer 容器 */
    #header-container, #footer-container {
      width: 100%;
    }
    /* Container + 卡片布局 */
    .container {
      flex: 1; width: 90%; max-width: 800px; margin: 20px auto;
    }
    .card {
      background: #fff; padding: 20px;
      border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin: 10px 0;
    }
    /* ========== 编辑器 ========== */
    #text-editor {
      width: 100%; min-height: 300px;
      border: 1px solid #ccc; padding: 12px; border-radius: 8px;
      outline: none; font-size: 16px; background: #fff;
      white-space: pre-wrap; transition: border 0.3s;
      -webkit-touch-callout: default; /* 允许触摸菜单 */
    }
    #text-editor:focus {
      border-color: #007bff;
    }
    #text-editor:empty:before {
      content: "Type here or drag a .doc/.txt file here";
      color: gray;
    }
    /* 高亮句子 */
    .highlighted-sentence {
      background-color: yellow;
    }
    /* 事件 / 录音状态等 */
    #mic-status {
      font-weight: bold; color: red;
    }
    #event-log {
      font-size: 14px; max-height: 200px;
      overflow-y: auto; background: #f9f9f9;
      padding: 10px; border: 1px solid #ccc; border-radius: 5px;
    }
    /* Overlay: 仅桌面弹出选择 */
    #select-overlay {
      position: fixed; width: 150px; height: 150px;
      border-radius: 50%; overflow: hidden; display: flex;
      border: 2px solid #007bff; background: rgba(255,255,255,0.95);
      left: 50%; top: 50%; transform: translate(-50%, -50%);
      z-index: 1000; transition: all 0.3s ease;
    }
    #select-overlay .half {
      width: 50%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      user-select: none; cursor: pointer; font-weight: bold;
      text-align: center; padding: 5px; background: #e7f0ff;
      transition: background 0.3s;
    }
    #select-overlay .half:hover { background: #d0e4ff; }
    #select-overlay .half.left {
      border-right: 1px solid #007bff;
    }
    @keyframes spin {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to   { transform: translate(-50%, -50%) rotate(360deg); }
    }
    .spinner {
      width: 150px; height: 150px;
      border: 8px solid #ccc; border-top-color: #007bff;
      border-radius: 50%; animation: spin 1s linear infinite;
      position: relative; top: 0; left: 0;
    }
    /* 浮动候选框 */
    .suggestions-box-floating {
      position: absolute; background: #fff; border: 1px solid #ccc; border-radius: 5px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15); padding: 5px; z-index: 2000;
      user-select: none; pointer-events: auto; max-height: 150px; overflow-y: auto;
    }
    .suggestions-box-floating div {
      padding: 8px; border-bottom: 1px solid #eee;
      cursor: pointer; transition: background 0.3s;
    }
    .suggestions-box-floating div:hover {
      background: #f0f0f0;
    }
    /* Toast 提示 */
    .toast {
      position: fixed; bottom: 20px; left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8); color: #fff;
      padding: 12px 24px; border-radius: 5px;
      z-index: 3000; opacity: 0; transition: opacity 0.5s ease;
    }
    /* 抽屉容器 (取代左下角按钮) */
    #drawer {
      position: fixed; bottom: 10px; left: 0; width: 240px;
      display: flex; flex-direction: column; gap: 10px;
      z-index: 3000; transition: transform 0.3s ease;
    }
    .drawer-collapsed { transform: translateX(-200px); }
    #drawer-toggle {
      display: flex; justify-content: flex-end; align-items: center;
      width: 240px; padding: 10px 14px; padding-right: 8px;
      font-size: 14px; border: none; border-radius: 6px;
      color: #fff; background: #007bff; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      cursor: pointer; transition: background 0.3s;
    }
    #drawer-toggle:hover { background: #0056b3; }
    #drawer button:not(#drawer-toggle) {
      padding: 10px 14px; font-size: 14px; border: none; border-radius: 6px;
      color: #fff; background: #007bff; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      cursor: pointer; transition: background 0.3s; width: 160px;
    }
    #drawer button:not(#drawer-toggle):hover { background: #0056b3; }
    @media (min-width: 481px) {
      #toggle-ime { display: none; }
    }
  </style>
</head>
<body>
  <header id="header-container"></header>

  <!-- 抽屉容器 -->
  <div id="drawer" class="drawer-collapsed">
    <button id="drawer-toggle" style="width: 240px; text-align: right;">&gt;</button>
    <button id="toggle-monitoring">Show Monitoring</button>
    <button id="toggle-log">Show Event Log</button>
    <button id="toggle-ime">Disable IME Shortcuts: OFF</button>
  </div>

  <div class="container">
    <!-- 监控区 -->
    <div class="card" id="monitoring-card">
      <p><strong>Error Sentence:</strong> <span id="error-text">None</span></p>
      <p><strong>Original Error Sentence:</strong> <span id="original-error-sentence">None</span></p>
      <p><strong>Touch Index (relative):</strong> <span id="touch-index">None</span></p>
      <p><strong>Speech Input:</strong> <span id="voice-input">None</span></p>
      <p><strong>Final Output:</strong> <span id="final-output">None</span></p>
      <p><strong>Recording Status:</strong> <span id="mic-status">🔴 Stopped</span></p>
    </div>

    <!-- 编辑器 + Undo 按钮 -->
    <div class="card">
      <h3>Tap&amp;Say Text Editor</h3>
      <div id="text-editor" contenteditable="true"></div>
      <button id="undo-button" style="
        margin-top: 12px; width: 100%; padding: 14px; font-size: 16px;
        border: none; border-radius: 6px; background: #28a745; color: #fff;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2); cursor: pointer;
      ">Undo Last Change</button>
    </div>

    <!-- 日志区 -->
    <div class="card" id="event-log-card">
      <h3>Event Log</h3>
      <div id="event-log">No events recorded</div>
    </div>
  </div>

  <footer id="footer-container"></footer>

  <script>
    /*******************************************************
     * 1) 全局变量 & 常量
     *******************************************************/
    const API_URL = "https://tns.zacchen.win/correct";
    const PUNCTUATION_API_URL = "https://tns.zacchen.win/restore_punctuation";

    let drawerOpen = false;
    const drawer = document.getElementById("drawer");
    const drawerToggle = document.getElementById("drawer-toggle");

    let disableIME = false;
    let selectOverlay = null;
    let overlayTimer = null;
    let pressTimer = null;
    let tapTriggered = false;
    let globalTapIndex = -1;  // 全文绝对index
    let localTapIndex = -1;   // 选中句子的相对index
    let initialX=0, initialY=0;
    let currentMode=null;     // "tap" or "voice"
    let recognition=null;
    let isListening=false;
    let silenceTimer=null;
    let originalSentence="";
    let suggestionsBox=null;
    let suggestionsTimer=null;
    let undoStack=[];

    const monitoringCard=document.getElementById("monitoring-card");
    const eventLogCard=document.getElementById("event-log-card");
    const editor=document.getElementById("text-editor");
    const errorText=document.getElementById("error-text");
    const originalErrorSpan=document.getElementById("original-error-sentence");
    const touchIndexSpan=document.getElementById("touch-index");
    const voiceInputSpan=document.getElementById("voice-input");
    const micStatusSpan=document.getElementById("mic-status");
    const finalOutputSpan=document.getElementById("final-output");
    const eventLog=document.getElementById("event-log");
    const undoButton=document.getElementById("undo-button");

    const monitoringBtn=document.getElementById("toggle-monitoring");
    const eventLogBtn=document.getElementById("toggle-log");
    const imeBtn=document.getElementById("toggle-ime");

    /*******************************************************
     * 2) onload
     *******************************************************/
    window.onload=function(){
      loadHeaderFooter();
      if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia){
        navigator.mediaDevices.getUserMedia({audio:true})
          .catch(err=>{
            showToast("Please allow microphone access to use Tap&Say.");
            console.warn("Mic permission error:", err);
          });
      }
    };
    async function loadHeaderFooter(){
      try {
        const headerRes=await fetch("header.html");
        const headerHtml=await headerRes.text();
        document.getElementById("header-container").innerHTML+=headerHtml;
      }catch(e){console.warn("Failed to load header.html:",e);}
      try {
        const footerRes=await fetch("footer.html");
        const footerHtml=await footerRes.text();
        document.getElementById("footer-container").innerHTML+=footerHtml;
      }catch(e){console.warn("Failed to load footer.html:",e);}
    }

    /*******************************************************
     * 3) 抽屉按钮
     *******************************************************/
    drawerToggle.addEventListener("click",()=>{
      drawerOpen=!drawerOpen;
      if(drawerOpen){
        drawer.classList.remove("drawer-collapsed");
        drawerToggle.innerText="<";
      }else{
        drawer.classList.add("drawer-collapsed");
        drawerToggle.innerText=">";
      }
    });

    /*******************************************************
     * 4) 监控 / 日志 / IME
     *******************************************************/
    monitoringBtn.addEventListener("click",()=>{
      monitoringCard.style.display=(monitoringCard.style.display==="none")?"block":"none";
      monitoringBtn.innerText=(monitoringCard.style.display==="none")?"Show Monitoring":"Hide Monitoring";
    });
    eventLogBtn.addEventListener("click",()=>{
      eventLogCard.style.display=(eventLogCard.style.display==="none")?"block":"none";
      eventLogBtn.innerText=(eventLogCard.style.display==="none")?"Show Event Log":"Hide Event Log";
    });
    imeBtn.addEventListener("click",()=>{
      disableIME=!disableIME;
      imeBtn.innerText= disableIME?"Disable IME Shortcuts: ON":"Disable IME Shortcuts: OFF";
      editor.style.webkitTouchCallout= disableIME?"none":"default";
    });

    /*******************************************************
     * 5) Toast & Log
     *******************************************************/
    function showToast(msg){
      const t=document.createElement("div");
      t.className="toast";
      t.innerText=msg;
      document.body.appendChild(t);
      requestAnimationFrame(()=>{ t.style.opacity=1; });
      setTimeout(()=>{
        t.style.opacity=0;
        setTimeout(()=>{ t.remove(); },500);
      },2000);
    }
    function logEvent(message){
      const p=document.createElement("p");
      const now=new Date().toLocaleString("en-US",{hour12:false});
      p.innerText=`[${now}] ${message}`;
      eventLog.appendChild(p);
    }

    /*******************************************************
     * 6) 文件拖拽
     *******************************************************/
    ["dragenter","dragover","dragleave","drop"].forEach(evtName=>{
      editor.addEventListener(evtName,e=>{
        e.preventDefault(); e.stopPropagation();
      },false);
    });
    editor.addEventListener("dragover",()=>{editor.style.background="#fafafa";});
    editor.addEventListener("dragleave",()=>{editor.style.background="white";});
    editor.addEventListener("drop", e=>{
      editor.style.background="white";
      const files=e.dataTransfer.files;
      if(files.length>0){
        const file=files[0];
        const fname=file.name.toLowerCase();
        if(fname.endsWith(".txt")||fname.endsWith(".doc")){
          let reader=new FileReader();
          reader.onload=function(evt){
            editor.innerText=evt.target.result;
            logEvent("File loaded: "+file.name);
          };
          reader.readAsText(file,"UTF-8");
        }else{
          showToast("Only .txt or .doc files are supported.");
        }
      }
    });

    /*******************************************************
     * 7) 长按 => Tap/Voice
     *******************************************************/
    editor.addEventListener("mousedown", onEditorMouseDown);
    editor.addEventListener("mouseup", onEditorMouseUp);
    editor.addEventListener("touchstart", onEditorTouchStart);
    editor.addEventListener("touchend", onEditorTouchEnd);

    function onEditorMouseDown(e){
      tapTriggered=false;
      globalTapIndex=getCaretIndex(e.clientX,e.clientY);
      initialX=e.clientX; initialY=e.clientY;
      pressTimer=setTimeout(()=>{
        tapTriggered=true;
        // 桌面弹出 overlay
        if(!isMobile() && !selectOverlay){
          showSelectOverlay(initialX,initialY);
        }
      },600);
    }
    function onEditorMouseUp(e){
      if(!tapTriggered) clearTimeout(pressTimer);
    }
    function onEditorTouchStart(e){
      tapTriggered=false;
      const touch=e.touches[0];
      globalTapIndex=getTouchIndex(touch.clientX,touch.clientY);
      initialX=touch.clientX; initialY=touch.clientY;
      pressTimer=setTimeout(()=>{
        tapTriggered=true;
        // 移动端直接Tap
        handleSelection("tap");
      },1000);
    }
    function onEditorTouchEnd(e){
      if(!tapTriggered) clearTimeout(pressTimer);
    }
    function isMobile(){
      return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    }
    function getTouchIndex(x,y){
      let rect=editor.getBoundingClientRect();
      let relativeX=x-rect.left;
      let totalChars=editor.innerText.length;
      if(totalChars===0) return 0;
      let ratio= relativeX/rect.width;
      if(ratio<0) ratio=0;
      if(ratio>1) ratio=1;
      return Math.floor(ratio*totalChars);
    }

    /*******************************************************
     * 8) 显示 overlay (桌面)
     *******************************************************/
    function showSelectOverlay(x,y){
      selectOverlay=document.createElement("div");
      selectOverlay.id="select-overlay";
      selectOverlay.style.left=x+"px";
      selectOverlay.style.top=y+"px";
      selectOverlay.innerHTML=`
        <div class="half left">Tap&amp;Say</div>
        <div class="half right">Voice Input</div>
      `;
      document.body.appendChild(selectOverlay);
      overlayTimer=setTimeout(()=>{ removeOverlay(); },3000);
      selectOverlay.querySelector(".half.left").onclick=()=>{
        clearTimeout(overlayTimer);
        handleSelection("tap");
      };
      selectOverlay.querySelector(".half.right").onclick=()=>{
        clearTimeout(overlayTimer);
        handleSelection("voice");
      };
    }
    function removeOverlay(){
      if(selectOverlay){
        selectOverlay.remove();
        selectOverlay=null;
      }
      if(overlayTimer){
        clearTimeout(overlayTimer);
        overlayTimer=null;
      }
    }

    /*******************************************************
     * 9) 建议框
     *******************************************************/
    function removeSuggestionsBox(){
      if(suggestionsBox){
        suggestionsBox.remove();
        suggestionsBox=null;
      }
      if(suggestionsTimer){
        clearTimeout(suggestionsTimer);
        suggestionsTimer=null;
      }
    }

    /*******************************************************
     * 10) handleSelection
     *******************************************************/
    function handleSelection(mode){
      removeSuggestionsBox();
      currentMode=mode;
      if(mode==="voice"){
        // 保存光标
        saveCurrentSelection();
      }else if(mode==="tap"){
        let {sentence, relativeIndex}= getSelectedSentenceAndRelativeIndex(globalTapIndex);
        sentence= sentence.trim();
        if(!sentence){
          logEvent("No valid sentence found for highlight");
          return;
        }
        localTapIndex=relativeIndex;
        touchIndexSpan.innerText= localTapIndex.toString();

        errorText.innerText= sentence;
        originalSentence= sentence;
        originalErrorSpan.innerText= sentence;
        undoStack.push(editor.innerHTML);
        removeHighlight();
        if(!highlightSentence(sentence)){
          logEvent("Highlight not found => "+ sentence);
        }
        // 移动光标到句末
        setTimeout(()=>{
          moveCaretToEndOfTarget();
          editor.focus();
        },50);
      }
      updateOverlayToSpinner();
      startRecording();
      setTimeout(()=>editor.focus(),0);
    }
    function updateOverlayToSpinner(){
      if(selectOverlay){
        selectOverlay.innerHTML='<div class="spinner"></div>';
      }
    }

    /*******************************************************
     * 11) 点击外面 => 移除建议 & 高亮
     *******************************************************/
    document.addEventListener("click",function(e){
      if(suggestionsBox && !suggestionsBox.contains(e.target)){
        removeSuggestionsBox();
      }
      let ts=document.getElementById("target-sentence");
      if(ts && !ts.contains(e.target)){
        removeHighlight();
      }
    });
    document.addEventListener("contextmenu",function(e){
      if(disableIME) e.preventDefault();
      if(currentMode==="tap" && selectOverlay){
        e.preventDefault();
        removeHighlight();
        replaceHighlightedSentence(originalSentence);
        removeOverlay();
      }
    });

    /*******************************************************
     * 12) 高亮
     *******************************************************/
    function highlightSentence(sentence){
      let html= editor.innerHTML;
      let safe= sentence.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
      const re= new RegExp(safe,"i");
      if(!re.test(html)) return false;
      editor.innerHTML= html.replace(re, `<span id="target-sentence" class="highlighted-sentence">$&</span>`);
      return true;
    }
    function removeHighlight(){
      let html= editor.innerHTML;
      html= html.replace(/<span id="target-sentence" class="highlighted-sentence">(.*?)<\/span>/i,"$1");
      editor.innerHTML= html;
    }
    function replaceHighlightedSentence(newText){
      let ts=document.getElementById("target-sentence");
      if(ts){
        ts.innerText=newText;
      }else{
        let html= editor.innerHTML;
        let safe= originalSentence.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
        const re= new RegExp(safe,"i");
        editor.innerHTML= html.replace(re,newText);
      }
    }

    /*******************************************************
     * 13) 录音
     *******************************************************/
    function startRecording(){
      if(!("SpeechRecognition" in window) && !("webkitSpeechRecognition" in window)){
        showToast("Speech recognition not supported in this browser.");
        finalizeTapSay();
        return;
      }
      let SpeechRecognition= window.SpeechRecognition||window.webkitSpeechRecognition;
      recognition=new SpeechRecognition();
      recognition.continuous=false; recognition.interimResults=false;
      recognition.lang="en-US";

      recognition.onstart=()=>{
        isListening=true;
        micStatusSpan.innerText="🟢 Recording...";
        silenceTimer=setTimeout(()=>{
          if(isListening) recognition.stop();
        },5000);
      };
      recognition.onresult=(e)=>{
        clearTimeout(silenceTimer);
        let txt="";
        for(let i=e.resultIndex;i< e.results.length;i++){
          txt+= e.results[i][0].transcript;
        }
        voiceInputSpan.innerText= txt;
      };
      recognition.onerror=(err)=>{
        micStatusSpan.innerText="❌ Recording error";
        if(isListening) recognition.stop();
        logEvent("Speech recognition error => "+ err.error);
      };
      recognition.onend=()=>{
        isListening=false;
        micStatusSpan.innerText="🔴 Stopped";
        finalizeTapSay();
      };
      recognition.start();
    }

    /*******************************************************
     * 14) Undo
     *******************************************************/
    undoButton.addEventListener("click",function(){
      if(undoStack.length>0){
        let prevState=undoStack.pop();
        editor.innerHTML= prevState;
        removeHighlight();
        showToast("Undo last change");
      } else {
        showToast("No change to undo!");
      }
      editor.focus();
    });

    /*******************************************************
     * 15) moveCaretToEndOfTarget
     *******************************************************/
    function moveCaretToEndOfTarget(){
      let ts=document.getElementById("target-sentence");
      if(!ts) return;
      editor.focus();
      let range= document.createRange();
      range.selectNodeContents(ts);
      range.collapse(false);
      let sel= window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }

    /*******************************************************
     * 16) finalizeTapSay
     *******************************************************/
    function finalizeTapSay(){
      removeOverlay();
      removeSuggestionsBox();
      let transcript= voiceInputSpan.innerText.trim();
      if(!transcript){
        showToast("No speech input detected.");
        currentMode=null;
        return;
      }
      undoStack.push(editor.innerHTML);

      if(currentMode==="voice"){
        let textNoPunc= removePunctuation(transcript);
        logEvent("Sending voice text to /restore_punctuation => "+ textNoPunc);

        fetch(PUNCTUATION_API_URL,{
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body: JSON.stringify({ voice_text: textNoPunc })
        })
        .then(resp=> resp.json())
        .then(data=>{
          let restored= data.restored_text||"";
          logEvent("Punctuation API returned => "+ restored);

          // 恢复光标 & 插入
          restoreCurrentSelection();
          let toInsert=" "+ restored.trim();
          insertTextAtCursor(toInsert);

          setTimeout(()=>{
            moveCaretToEndOfTarget();
            editor.focus();
          },50);
        })
        .catch(err=>{
          logEvent("Punctuation API call error => "+ err);
        });
      } else {
        let parted= errorText.innerText||"";
        parted= parted.trimEnd();
        parted= parted.replace(/([.!?])(\S)/g,"$1 $2");

        let textNoPunc= removePunctuation(transcript).trimEnd();
        let merged= parted+" <||> "+ textNoPunc;
        merged= merged.trimEnd();
        finalOutputSpan.innerText= merged;
        logEvent("Final output => "+ merged);

        sendToAPI(merged, localTapIndex);
        setTimeout(()=>{
          moveCaretToEndOfTarget();
          editor.focus();
        },50);
      }
      currentMode=null;
      voiceInputSpan.innerText="";
    }

    /*******************************************************
     * 17) /correct
     *******************************************************/
    function sendToAPI(mergedStr, loc){
      logEvent("Sending /correct => merged_string:"+ mergedStr+", touch_location:"+ loc);
      fetch(API_URL,{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({
          merged_string: mergedStr,
          touch_location: loc
        })
      })
      .then(resp=> resp.json())
      .then(data=>{
        let corrs= data.corrections||[];
        logEvent("API corrections => "+ JSON.stringify(corrs));
        removeOverlay();
        applyFirstSuggestionAndShowBox(corrs);
      })
      .catch(err=>{
        logEvent("API call error => "+ err);
        removeOverlay();
      });
    }

    /*******************************************************
     * 18) applyFirstSuggestionAndShowBox
     *******************************************************/
    function applyFirstSuggestionAndShowBox(corrections){
      if(!corrections.length) return;
      let ts=document.getElementById("target-sentence");
      let candidate= corrections[0].trimEnd();
      if(ts){
        ts.innerText= candidate;
        originalSentence= candidate;
        removeHighlight();
        highlightSentence(candidate);

        setTimeout(()=>{
          maybeAddSpaceAfterHighlight(ts);
          moveCaretToEndOfTarget();
          editor.focus();
        },50);
      } else {
        let html= editor.innerHTML;
        let safe= originalSentence.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
        const re= new RegExp(safe,"i");
        if(!re.test(html)){
          logEvent("No highlighted sentence found => "+ originalSentence);
          return;
        }
        editor.innerHTML= html.replace(re,candidate);
        originalSentence= candidate;
        removeHighlight();
        highlightSentence(candidate);

        setTimeout(()=>{
          let ts2=document.getElementById("target-sentence");
          if(ts2) maybeAddSpaceAfterHighlight(ts2);
          moveCaretToEndOfTarget();
          editor.focus();
        },50);
      }
      if(corrections.length===1) return;

      let tsNew=document.getElementById("target-sentence");
      if(!tsNew){
        logEvent("No highlighted sentence found for suggestions.");
        return;
      }
      let rect= tsNew.getBoundingClientRect();
      suggestionsBox= createSuggestionBox(rect, corrections);
      document.body.appendChild(suggestionsBox);
      suggestionsTimer= setTimeout(()=>{ removeSuggestionsBox(); },5000);
    }

    /*******************************************************
     * 19) createSuggestionBox
     *******************************************************/
    function createSuggestionBox(rect, corrections){
      let box=document.createElement("div");
      box.className="suggestions-box-floating";
      box.style.left=(rect.left+window.scrollX)+"px";
      box.style.top=(rect.bottom+window.scrollY)+"px";
      box.style.width= rect.width+"px";

      for(let i=1;i<corrections.length;i++){
        let div=document.createElement("div");
        div.innerText= corrections[i];
        div.onclick=(evt)=>{
          evt.preventDefault(); evt.stopPropagation();

          removeHighlight();
          let ts=document.getElementById("target-sentence");
          let candidate= corrections[i].trimEnd();

          if(ts){
            ts.innerText= candidate;
            originalSentence= candidate;
            removeHighlight();
            highlightSentence(candidate);

            setTimeout(()=>{
              maybeAddSpaceAfterHighlight(ts);
              moveCaretToEndOfTarget();
              editor.focus();
            },50);
          } else {
            let html= editor.innerHTML;
            let safe= originalSentence.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
            const re= new RegExp(safe,"i");
            editor.innerHTML= html.replace(re,candidate);
            originalSentence= candidate;
            highlightSentence(candidate);

            setTimeout(()=>{
              let ts2=document.getElementById("target-sentence");
              if(ts2) maybeAddSpaceAfterHighlight(ts2);
              moveCaretToEndOfTarget();
              editor.focus();
            },50);
          }
          removeSuggestionsBox();
        };
        box.appendChild(div);
      }
      return box;
    }

    /*******************************************************
     * 20) 工具函数
     *******************************************************/
    function maybeAddSpaceAfterHighlight(ts){
      let parent= ts.parentNode; if(!parent) return;

      let next= ts.nextSibling;
      while(next && next.nodeType===Node.ELEMENT_NODE && !next.textContent.trim()){
        next= next.nextSibling;
      }
      if(!next){
        if(!endsWithSpaceOrPunc(ts.innerText)){
          ts.innerText= ts.innerText+" ";
        }
        return;
      }
      if(next.nodeType===Node.TEXT_NODE){
        let t= next.nodeValue;
        if(!t|| t.length===0){
          if(!endsWithSpaceOrPunc(ts.innerText)){
            ts.innerText+=" ";
          }
        } else {
          if(!t[0].match(/[\s.,;!?]/)){
            if(!endsWithSpaceOrPunc(ts.innerText)){
              ts.innerText+=" ";
            }
          }
        }
      } else if(next.nodeType===Node.ELEMENT_NODE){
        let text= next.textContent.trimStart();
        if(text.length===0){
          if(!endsWithSpaceOrPunc(ts.innerText)){
            ts.innerText+=" ";
          }
        } else {
          if(!text[0].match(/[\s.,;!?]/)){
            if(!endsWithSpaceOrPunc(ts.innerText)){
              ts.innerText+=" ";
            }
          }
        }
      }
    }
    function endsWithSpaceOrPunc(str){
      if(!str) return false;
      let c= str[str.length-1];
      return !!c.match(/[\s.,;!?]/);
    }

    function insertTextAtCursor(text){
      editor.focus();
      let sel= window.getSelection();
      if(sel.rangeCount>0){
        let range= sel.getRangeAt(0);
        range.deleteContents();
        let textNode= document.createTextNode(text);
        range.insertNode(textNode);
        range.setStartAfter(textNode);
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
      } else {
        editor.innerHTML+= text;
      }
    }
    function getCaretIndex(x,y){
      let range;
      if(document.caretRangeFromPoint){
        range= document.caretRangeFromPoint(x,y);
      } else if(document.caretPositionFromPoint){
        let pos= document.caretPositionFromPoint(x,y);
        if(!pos) return -1;
        range= document.createRange();
        range.setStart(pos.offsetNode, pos.offset);
        range.collapse(true);
      }
      if(!range) return -1;
      let pre= range.cloneRange();
      pre.selectNodeContents(editor);
      pre.setEnd(range.startContainer, range.startOffset);
      return pre.toString().length;
    }
    function getSelectedSentenceAndRelativeIndex(globalIndex){
      let text= editor.innerText;
      let sentences= text.match(/[^.!?。！？]*[.!?。！？]/gi)|| [text];
      let selectedSentence= sentences.find(s=>{
        let idx= text.toLowerCase().indexOf(s.toLowerCase());
        return idx>=0 && idx<=globalIndex && (idx+s.length)>=globalIndex;
      })|| text;
      let startIndex= text.toLowerCase().indexOf(selectedSentence.toLowerCase());
      let relIndex= globalIndex- startIndex;
      return { sentence:selectedSentence, relativeIndex:relIndex };
    }
  </script>
</body>
</html>
